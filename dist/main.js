(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["dbdi"] = factory();
	else
		root["dbdi"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";
/******/
/******/ 	var jsonpArray = window["webpackJsonpdbdi"] = window["webpackJsonpdbdi"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([0,"vendor","common"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./DataReadDescriptor.js":
/*!*******************************!*\
  !*** ./DataReadDescriptor.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataReadDescriptor; });\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isArray */ \"../node_modules/lodash/isArray.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_partial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/partial */ \"../node_modules/lodash/partial.js\");\n/* harmony import */ var lodash_partial__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_partial__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _DataDescriptorNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DataDescriptorNode */ \"./DataDescriptorNode.js\");\n/* harmony import */ var _PathDescriptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathDescriptor */ \"./PathDescriptor.js\");\n/* harmony import */ var _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataProviders/DataProviderBase */ \"./dataProviders/DataProviderBase.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\nvar DataReadDescriptor =\n/*#__PURE__*/\nfunction (_DataDescriptorNode) {\n  _inherits(DataReadDescriptor, _DataDescriptorNode);\n\n  function DataReadDescriptor(pathDescriptor, reader, fetch, name) {\n    var _this;\n\n    _classCallCheck(this, DataReadDescriptor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DataReadDescriptor).call(this, {\n      pathDescriptor: pathDescriptor,\n      reader: reader,\n      fetch: fetch\n    }, name));\n\n    _defineProperty(_assertThisInitialized(_this), \"readData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"readAsync\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"reader\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"fetch\", void 0);\n\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_4___default()(_assertThisInitialized(_this));\n    _this.reader = reader;\n    _this.fetch = fetch;\n\n    _this._buildReaders();\n\n    return _this;\n  }\n\n  _createClass(DataReadDescriptor, [{\n    key: \"_buildReaders\",\n    // ####################################################################################################\n    // _buildReadData\n    // ####################################################################################################\n    value: function _buildReaders() {\n      // build reader from pathDescriptor\n      this.readData = new ImmediateRead().buildReader(this);\n      this.readAsync = new AsyncRead().buildReader(this);\n    } // ################################################\n    // Public properties + methods\n    // ################################################\n\n    /**\n     * Check if data is loaded\n     */\n\n  }, {\n    key: \"isDataLoaded\",\n    value: function isDataLoaded() {\n      // TODO: fix this!\n      // 1) check if all dependencies are loaded\n      // if (!this.areDependenciesLoaded(args)) {\n      //   return false;\n      // }\n      var data = this.readData.apply(this, arguments);\n      return data !== _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__[\"NOT_LOADED\"];\n    }\n  }, {\n    key: \"pathDescriptor\",\n    get: function get() {\n      return this._cfg.pathDescriptor;\n    }\n  }, {\n    key: \"readMod\",\n    get: function get() {\n      return this.reader;\n    }\n  }, {\n    key: \"nodeType\",\n    get: function get() {\n      return 'DataRead';\n    }\n  }]);\n\n  return DataReadDescriptor;\n}(_DataDescriptorNode__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n/**\n * The final read data function has many levels.\n * readAsync cuts some corners, but also needs special handling for promises.\n */\n\n\n\n\nvar PathDescriptorReader =\n/*#__PURE__*/\nfunction () {\n  function PathDescriptorReader() {\n    var _this2 = this;\n\n    _classCallCheck(this, PathDescriptorReader);\n\n    _defineProperty(this, \"dataReadDescriptor\", void 0);\n\n    _defineProperty(this, \"_doRead\", void 0);\n\n    _defineProperty(this, \"wrappedRead\", function () {// 0) Wrap everything in a big old try/catch, so we can throw a meaningful error message\n    });\n\n    _defineProperty(this, \"customReadOnly\", function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      var reader = _this2.dataReadDescriptor.reader;\n      return reader(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n    });\n\n    _defineProperty(this, \"readFromPathDescriptor\", function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      // // TODO check if all dependencies are loaded?\n      // if (!this.areDependenciesLoaded()) { ... }\n      // 1) Get the path/queryInput(s) (essentially a higher level version of a \"query\")\n      var _this2$dataReadDescri = _this2.dataReadDescriptor,\n          pathDescriptor = _this2$dataReadDescri.pathDescriptor,\n          readMod = _this2$dataReadDescri.readMod; // TODO: Make getPath work properly with async fetch\n\n      var queryInput = pathDescriptor.getPath(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n      if (queryInput === _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__[\"NOT_LOADED\"]) {\n        return _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__[\"NOT_LOADED\"];\n      } // 2) Read data for given queryInput\n      // 2.a) Record access with DataAccessTracker (if needed)\n      // 2.b) Read data from data provider\n\n\n      var result = _this2.readFromCache(queryInput, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker); // 3) If data is not present, do the fetch thing\n\n\n      if (result === _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__[\"NOT_LOADED\"]) {\n        result = _this2.doFetch(queryInput, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n      } // 4) If there is a custom reader (readMod), use that to modify the result\n\n\n      if (readMod) {\n        result = _this2.applyReadMod(result, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n      }\n\n      return result;\n    });\n  }\n\n  _createClass(PathDescriptorReader, [{\n    key: \"getFetchInHierarchy\",\n    // TODO: make fetch work through-out the hierarchy\n    value: function getFetchInHierarchy() {\n      // -> in case, this node does not have a fetch entry, but any of it's parents does, \n      //      -> go to the closest parent and fetch that first\n      // TODO: Problem - queryInput and callerNode need to be fixed correspondingly\n      // TODO: hierarchical fetch lookup must be implemented in every place where fetch is used\n      // let node = !fetch && callerNode.parent;\n      // while (!fetch && node) {\n      //   if (node.readDescriptor) {\n      //     fetch = node.readDescriptor.fetch;\n      //   }\n      //   if (node.parent) {\n      //     node = node.parent;\n      //   }\n      // }\n      var fetch = this.dataReadDescriptor.fetch;\n      return fetch;\n    }\n  }, {\n    key: \"buildReader\",\n    value: function buildReader(dataReadDescriptor) {\n      this.dataReadDescriptor = dataReadDescriptor;\n      var fetch = this.getFetchInHierarchy();\n\n      if (dataReadDescriptor.pathDescriptor) {\n        this._doRead = this.readFromPathDescriptor;\n      } else if (fetch && dataReadDescriptor.reader) {\n        this._doRead = this.customFetchAndRead;\n      } else if (fetch) {\n        this._doRead = this.customFetchOnly;\n      } else if (dataReadDescriptor.reader) {\n        this._doRead = this.customReadOnly;\n      } else {\n        throw new Error(\"Could not make sense of DataReadDescriptor config node '\".concat(dataReadDescriptor.name, \"' - Must either have 'path', 'reader' and/or 'fetch' property.\\n\").concat(JSON.stringify(dataReadDescriptor._cfg, null, 2)));\n      }\n\n      if (!this._doRead) {\n        console.assert(this._doRead, 'something went wrong in PathDescriptorReader');\n        debugger;\n      }\n\n      return this.wrappedRead;\n    }\n  }]);\n\n  return PathDescriptorReader;\n}();\n\nvar ImmediateRead =\n/*#__PURE__*/\nfunction (_PathDescriptorReader) {\n  _inherits(ImmediateRead, _PathDescriptorReader);\n\n  function ImmediateRead() {\n    var _getPrototypeOf2;\n\n    var _this3;\n\n    _classCallCheck(this, ImmediateRead);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this3 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ImmediateRead)).call.apply(_getPrototypeOf2, [this].concat(_args)));\n\n    _defineProperty(_assertThisInitialized(_this3), \"wrappedRead\", function () {\n      try {\n        var _this4;\n\n        return (_this4 = _this3)._doRead.apply(_this4, arguments);\n      } catch (err) {\n        throw new Error(\"Failed to read from node \\\"\".concat(_this3.dataReadDescriptor.name, \"\\\":\\n\") + (err && err.stack || err));\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this3), \"customFetchOnly\", function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      // fetch is an asynchronous call that returns a prommise, and not an immediate value\n      throw new Error('Invalid immediate read on node that does neither have path nor custom reader. ' + 'Maybe you wanted to call readAsync (which returns a promise) instead?');\n    });\n\n    _defineProperty(_assertThisInitialized(_this3), \"customFetchAndRead\", function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      // ignore fetch for immediate read\n      return _this3.customReadOnly(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n    });\n\n    _defineProperty(_assertThisInitialized(_this3), \"readFromCache\", function (queryInput, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      var dataProvider = callerNode.dataProvider; // start listening on + loading from the given path (queryInput)\n\n      accessTracker._recordDataAccess(dataProvider, queryInput); // read data\n\n\n      return dataProvider.readData(queryInput);\n    });\n\n    _defineProperty(_assertThisInitialized(_this3), \"doFetch\", function (queryInput, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      var dataProvider = callerNode.dataProvider;\n\n      var fetch = _this3.getFetchInHierarchy();\n\n      if (!fetch) return _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__[\"NOT_LOADED\"];\n\n      _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var res;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return dataProvider.fetchStart(queryInput);\n\n              case 2:\n                if (!_context.sent) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.prev = 3;\n                _context.next = 6;\n                return fetch(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n              case 6:\n                res = _context.sent;\n                dataProvider.fetchEnd(queryInput, res);\n                _context.next = 13;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](3);\n                //throw new Error(\n                dataProvider.fetchFailed(queryInput, _context.t0);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 10]]);\n      }))();\n\n      return _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_7__[\"NOT_LOADED\"];\n    });\n\n    return _this3;\n  }\n\n  _createClass(ImmediateRead, [{\n    key: \"applyReadMod\",\n    value: function applyReadMod(result, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      var readMod = this.dataReadDescriptor.readMod; //if (reader) \n\n      {\n        result = readMod(result, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n      }\n      return result;\n    }\n  }]);\n\n  return ImmediateRead;\n}(PathDescriptorReader); // ####################################################################################################\n// AsyncRead\n// ####################################################################################################\n\n/**\n * AsyncRead is used for the readAsync method which is an asynchronous one-shot read or fetch\n * and does not trigger cache or listener updates.\n */\n\n\nvar AsyncRead =\n/*#__PURE__*/\nfunction (_PathDescriptorReader2) {\n  _inherits(AsyncRead, _PathDescriptorReader2);\n\n  function AsyncRead() {\n    var _getPrototypeOf3;\n\n    var _this5;\n\n    _classCallCheck(this, AsyncRead);\n\n    for (var _len2 = arguments.length, _args3 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _args3[_key2] = arguments[_key2];\n    }\n\n    _this5 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(AsyncRead)).call.apply(_getPrototypeOf3, [this].concat(_args3)));\n\n    _defineProperty(_assertThisInitialized(_this5), \"wrappedRead\",\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee2() {\n      var _this6,\n          _args4 = arguments;\n\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return (_this6 = _this5)._doRead.apply(_this6, _args4);\n\n            case 3:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](0);\n              throw new Error(\"Failed to read from node \\\"\".concat(_this5.dataReadDescriptor.name, \"\\\":\\n\") + (_context2.t0 && _context2.t0.stack || _context2.t0));\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this, [[0, 6]]);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this5), \"customReadOnly\", function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      throw new Error('Tried to fetch data asynchronously from reader that neither defined `fetch` nor `path'); // const { reader } = this.dataReadDescriptor;\n      // return reader(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n    });\n\n    _defineProperty(_assertThisInitialized(_this5), \"customFetchOnly\",\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n        var fetch, result;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                fetch = _this5.getFetchInHierarchy();\n                _context3.next = 3;\n                return fetch(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n              case 3:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", result);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function (_x, _x2, _x3, _x4, _x5, _x6) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this5), \"customFetchAndRead\",\n    /*#__PURE__*/\n    function () {\n      var _ref4 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n        var fetch, result;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                fetch = _this5.getFetchInHierarchy();\n                _context4.next = 3;\n                return fetch(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n              case 3:\n                result = _context4.sent;\n                _context4.next = 6;\n                return _this5.applyReadMod(result, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n              case 6:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", result);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function (_x7, _x8, _x9, _x10, _x11, _x12) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this5), \"readFromCache\", function (queryInput, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      var dataProvider = callerNode.dataProvider; // NOTE: we don't need to tell the DataAccessTracker, since we don't need data binding for this.\n      // read data\n\n      return dataProvider.readData(queryInput);\n    });\n\n    _defineProperty(_assertThisInitialized(_this5), \"doFetch\",\n    /*#__PURE__*/\n    function () {\n      var _ref5 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee5(queryInput, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n        var dataProvider, fetch;\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                dataProvider = callerNode.dataProvider;\n                fetch = _this5.getFetchInHierarchy(); //console.warn(this.dataReadDescriptor, queryInput, fetch, pathDescriptor);\n\n                if (!fetch) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                _context5.next = 5;\n                return fetch(args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n              case 5:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 6:\n                _context5.next = 8;\n                return dataProvider.fetchOnce(queryInput);\n\n              case 8:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function (_x13, _x14, _x15, _x16, _x17, _x18, _x19) {\n        return _ref5.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this5), \"applyReadMod\",\n    /*#__PURE__*/\n    function () {\n      var _ref6 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee6(result, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n        var readMod;\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return result;\n\n              case 2:\n                result = _context6.sent;\n                readMod = _this5.dataReadDescriptor.readMod;\n                _context6.next = 6;\n                return readMod(result, args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n\n              case 6:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function (_x20, _x21, _x22, _x23, _x24, _x25, _x26) {\n        return _ref6.apply(this, arguments);\n      };\n    }());\n\n    return _this5;\n  }\n\n  return AsyncRead;\n}(PathDescriptorReader); // /**\n//  * Check if all dependencies are loaded\n//  * \n//  * @param {*} args\n//  */\n// areDependenciesLoaded(args) {\n//   // NOTE: knownDependencies are defined by the createPathTemplate* functions.\n//   //   These dependencies are currently only obtained from caller-provided arguments.\n//   // const knownDependencies = this._descriptor.getDependencies();\n//   // if (!isEmpty(knownDependencies)) {\n//   //   if (some(\n//   //     knownDependencies,\n//   //     sourceName => args[sourceName] !== null\n//   //   )) {\n//   //     return false;\n//   //   }\n//   // }\n//   return true;\n// }\n\n//# sourceURL=webpack://dbdi/./DataReadDescriptor.js?");

/***/ }),

/***/ "./DataSourceNode.js":
/*!***************************!*\
  !*** ./DataSourceNode.js ***!
  \***************************/
/*! exports provided: default, AmbiguousSourceNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataSourceNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AmbiguousSourceNode\", function() { return AmbiguousSourceNode; });\n/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/reduce */ \"../node_modules/lodash/reduce.js\");\n/* harmony import */ var lodash_reduce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_reduce__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/forEach */ \"../node_modules/lodash/forEach.js\");\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var src_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/util */ \"./util/index.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n // TODO: let all data path/read/write nodes of the same name easily access each other\n\n/**\n * The DataSourceNode provides access to a specific name in the data hierarchy \n * through di (dependency injection) proxies and is at the core of the data model.\n * The node has access to all the named nodes defined in it and it's descendants (if named unambiguously).\n * The node connects the (Path/DataRead/DataWrite)Descriptors' with the given DataProviders.\n */\n\nvar DataSourceNode =\n/*#__PURE__*/\nfunction () {\n  function DataSourceNode(tree, cfg, parent, dataProvider, name, fullName, pathDescriptor, readDescriptor, writeDescriptor) {\n    _classCallCheck(this, DataSourceNode);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"cfg\", void 0);\n\n    _defineProperty(this, \"fullName\", void 0);\n\n    _defineProperty(this, \"_tree\", void 0);\n\n    _defineProperty(this, \"_parent\", void 0);\n\n    _defineProperty(this, \"_dataProvider\", void 0);\n\n    _defineProperty(this, \"_pathDescriptor\", void 0);\n\n    _defineProperty(this, \"_writeDescriptor\", void 0);\n\n    _defineProperty(this, \"_readDescriptor\", void 0);\n\n    _defineProperty(this, \"_children\", {});\n\n    _defineProperty(this, \"_readDescendants\", {});\n\n    _defineProperty(this, \"_writeDescendants\", {});\n\n    //console.log('Building DataSourceNode: ' + name);\n    this.name = name;\n    this.cfg = cfg;\n    this.fullName = fullName;\n    this._tree = tree;\n    this._parent = parent;\n    this._dataProvider = dataProvider;\n    this._pathDescriptor = pathDescriptor;\n    this._readDescriptor = readDescriptor;\n    this._writeDescriptor = writeDescriptor;\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_2___default()(this);\n    this.readData.isLoaded = this.isDataLoaded;\n    this.readData.areAllLoaded = this.areAllLoaded;\n  } // ################################################\n  // Public properties + methods\n  // ################################################\n\n\n  _createClass(DataSourceNode, [{\n    key: \"isDataLoaded\",\n    value: function isDataLoaded() {\n      return this.readData.apply(this, arguments) !== undefined;\n    }\n  }, {\n    key: \"areAllLoaded\",\n    value: function areAllLoaded(idArgs) {\n      var _this = this;\n\n      for (var _len = arguments.length, allArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        allArgs[_key - 1] = arguments[_key];\n      }\n\n      return lodash_reduce__WEBPACK_IMPORTED_MODULE_0___default()(idArgs, function (idArg, res) {\n        return res | _this.isDataLoaded.apply(_this, [idArg].concat(allArgs));\n      }, true);\n    }\n  }, {\n    key: \"readData\",\n    value: function readData(args, readerProxy, injectProxy, writerProxy, accessTracker) {\n      args = args || src_util__WEBPACK_IMPORTED_MODULE_3__[\"EmptyObject\"];\n\n      if (!this._readDescriptor) {\n        throw new Error(\"Tried to read data from \\\"\".concat(this.fullName, \"\\\", \\n        but node does not have a reader.\"));\n      }\n\n      return this._readDescriptor.readData(args, readerProxy, injectProxy, writerProxy, this, accessTracker);\n    }\n  }, {\n    key: \"readAsync\",\n    value: function () {\n      var _readAsync = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee(args, readerProxy, injectProxy, writerProxy, accessTracker) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                args = args || src_util__WEBPACK_IMPORTED_MODULE_3__[\"EmptyObject\"];\n\n                if (this._readDescriptor) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Tried to read data from \\\"\".concat(this.fullName, \"\\\", \\n        but node does not have a reader.\"));\n\n              case 3:\n                _context.next = 5;\n                return this._readDescriptor.readAsync(args, readerProxy, injectProxy, writerProxy, this, accessTracker);\n\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function readAsync(_x, _x2, _x3, _x4, _x5) {\n        return _readAsync.apply(this, arguments);\n      }\n\n      return readAsync;\n    }()\n  }, {\n    key: \"writeData\",\n    value: function writeData(args, readerProxy, injectProxy, writerProxy, accessTracker) {\n      args = args || src_util__WEBPACK_IMPORTED_MODULE_3__[\"EmptyObject\"];\n\n      if (!this._writeDescriptor) {\n        throw new Error(\"Tried to write data to \\\"\".concat(this.fullName, \"\\\",\\n        but node does not have a writer.\"));\n      }\n\n      return this._writeDescriptor.writeData(args, readerProxy, injectProxy, writerProxy, this, accessTracker);\n    }\n  }, {\n    key: \"forEachNodeInSubTree\",\n    value: function forEachNodeInSubTree(fn) {\n      fn(this);\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(this._children, function (child) {\n        return child.forEachNodeInSubTree(fn);\n      });\n    }\n  }, {\n    key: \"getReadDescendantByName\",\n    value: function getReadDescendantByName(name) {\n      return this._readDescendants[name];\n    }\n  }, {\n    key: \"getWriteDescendantByName\",\n    value: function getWriteDescendantByName(name) {\n      return this._writeDescendants[name];\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n  }, {\n    key: \"dataProvider\",\n    get: function get() {\n      return this._dataProvider;\n    }\n  }, {\n    key: \"pathDescriptor\",\n    get: function get() {\n      return this._pathDescriptor;\n    }\n  }, {\n    key: \"readDescriptor\",\n    get: function get() {\n      return this._readDescriptor;\n    }\n  }, {\n    key: \"writeDescriptor\",\n    get: function get() {\n      return this._writeDescriptor;\n    }\n  }, {\n    key: \"isReader\",\n    get: function get() {\n      return !!this._readDescriptor;\n    } // has custom writer or path\n\n  }, {\n    key: \"isWriter\",\n    get: function get() {\n      // If it has path, will have a corresponding set_* writer\n      return !!this._writeDescriptor || !!this.pathDescriptor;\n    }\n  }]);\n\n  return DataSourceNode;\n}();\n/**\n * Represents a source node that shares the name with at least one other node\n */\n\n\n\nvar AmbiguousSourceNode =\n/*#__PURE__*/\nfunction () {\n  /**\n   * fullNames of all nodes that have the same name as this node\n   */\n  function AmbiguousSourceNode(name) {\n    _classCallCheck(this, AmbiguousSourceNode);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"fullNames\", void 0);\n\n    this.name = name;\n\n    for (var _len2 = arguments.length, fullNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      fullNames[_key2 - 1] = arguments[_key2];\n    }\n\n    this.fullNames = fullNames;\n  } // ################################################\n  // Public properties + methods\n  // ################################################\n\n\n  _createClass(AmbiguousSourceNode, [{\n    key: \"isDataLoaded\",\n    value: function isDataLoaded() {\n      throw new Error('[ERROR] Tried to call isDataLoaded on ' + this);\n    }\n  }, {\n    key: \"areAllLoaded\",\n    value: function areAllLoaded() {\n      throw new Error('[ERROR] Tried to call areAllLoaded on ' + this);\n    }\n  }, {\n    key: \"readData\",\n    value: function readData() {\n      throw new Error('[ERROR] Tried to call readData on ' + this);\n    }\n  }, {\n    key: \"writeData\",\n    value: function writeData() {\n      throw new Error('[ERROR] Tried to call writeData on ' + this);\n    }\n  }, {\n    key: \"forEachNodeInSubTree\",\n    value: function forEachNodeInSubTree() {\n      throw new Error('[ERROR] Tried to call forEachNodeInSubTree on ' + this);\n    }\n  }, {\n    key: \"getReadDescendantByName\",\n    value: function getReadDescendantByName() {\n      throw new Error('[ERROR] Tried to call getReadDescendantByName on ' + this);\n    }\n  }, {\n    key: \"getWriteDescendantByName\",\n    value: function getWriteDescendantByName() {\n      throw new Error('[ERROR] Tried to call getWriteDescendantByName on ' + this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Ambiguous node \\\"\".concat(this.name, \"\\\", might refer to any of: [\").concat(this.fullNames.join(', '), \"]\");\n    }\n  }, {\n    key: \"dataProvider\",\n    get: function get() {\n      throw new Error('[ERROR] Tried to get dataProvider from ' + this);\n    }\n  }, {\n    key: \"pathDescriptor\",\n    get: function get() {\n      throw new Error('[ERROR] Tried to get pathDescriptor from ' + this);\n    }\n  }, {\n    key: \"readDescriptor\",\n    get: function get() {\n      throw new Error('[ERROR] Tried to get readDescriptor from ' + this);\n    }\n  }, {\n    key: \"writeDescriptor\",\n    get: function get() {\n      throw new Error('[ERROR] Tried to get writeDescriptor from ' + this);\n    }\n  }, {\n    key: \"isReader\",\n    get: function get() {\n      throw new Error('[ERROR] Tried to call isReader on ' + this);\n    }\n  }, {\n    key: \"isWriter\",\n    get: function get() {\n      throw new Error('[ERROR] Tried to call isWriter on ' + this);\n    }\n  }]);\n\n  return AmbiguousSourceNode;\n}();\n\n//# sourceURL=webpack://dbdi/./DataSourceNode.js?");

/***/ }),

/***/ "./DataSourceTree.js":
/*!***************************!*\
  !*** ./DataSourceTree.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return buildSourceTree; });\n/* harmony import */ var _DataStructureConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataStructureConfig */ \"./DataStructureConfig.js\");\n/* harmony import */ var _PathDescriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathDescriptor */ \"./PathDescriptor.js\");\n/* harmony import */ var _DataReadDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataReadDescriptor */ \"./DataReadDescriptor.js\");\n/* harmony import */ var _DataWriteDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataWriteDescriptor */ \"./DataWriteDescriptor.js\");\n/* harmony import */ var _DataSourceNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DataSourceNode */ \"./DataSourceNode.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isArray */ \"../node_modules/lodash/isArray.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/forEach */ \"../node_modules/lodash/forEach.js\");\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/map */ \"../node_modules/lodash/map.js\");\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/mapValues */ \"../node_modules/lodash/mapValues.js\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var lodash_pickBy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/pickBy */ \"../node_modules/lodash/pickBy.js\");\n/* harmony import */ var lodash_pickBy__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(lodash_pickBy__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var lodash_zipObject__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/zipObject */ \"../node_modules/lodash/zipObject.js\");\n/* harmony import */ var lodash_zipObject__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash_zipObject__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash/merge */ \"../node_modules/lodash/merge.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _DataAccessTracker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./DataAccessTracker */ \"./DataAccessTracker.js\");\n/* harmony import */ var _plugins_DataRelationshipGraph__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/DataRelationshipGraph */ \"./plugins/DataRelationshipGraph.js\");\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //import { EmptyObject, EmptyArray } from 'src/util';\n\n\n/**\n * For now, we just add the default plugins.\n * Eventually, we can easily put them into separate NPM modules.\n * (because there is no specialized code outside of the plugins referring to the plugins)\n */\n\n\n\nfunction addDefaultPlugins(plugins) {\n  lodash_merge__WEBPACK_IMPORTED_MODULE_13___default()(plugins, {\n    // invoked via: this._notifyPlugins('tree', this);\n    tree: [_plugins_DataRelationshipGraph__WEBPACK_IMPORTED_MODULE_16__[\"DataRelationshipPlugin\"]]\n  });\n}\n/**\n * @returns {DataSourceTree}\n */\n\n\nfunction buildSourceTree(dataProviders, dataStructureCfgRaw, plugins) {\n  plugins = plugins || {};\n  addDefaultPlugins(plugins);\n  var tree = new DataSourceTree(dataProviders, dataStructureCfgRaw, plugins);\n\n  tree._buildTree();\n\n  return tree;\n}\n/**\n * A DataSource is responsible for providing data read + write operations to any part of a web app.\n * \n * In React, a DataSource is injected into the context through the DataSourceProvider component.\n * It uses a pub-sub model to keep track of data updates.\n */\n\nvar DataSourceTree =\n/*#__PURE__*/\nfunction () {\n  /**\n   * All DataSourceNodes\n   */\n  function DataSourceTree(dataProviders, dataStructureCfgRaw, plugins) {\n    var _this = this;\n\n    _classCallCheck(this, DataSourceTree);\n\n    _defineProperty(this, \"_dataProviders\", void 0);\n\n    _defineProperty(this, \"_plugins\", void 0);\n\n    _defineProperty(this, \"_pluginInstances\", {});\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_defaultWriteOps\", ['push', 'set', 'update', 'delete']);\n\n    _defineProperty(this, \"_customWritePathDescriptors\", {\n      push: function push(pathDescriptor) {\n        return pathDescriptor.getParentPathDescriptor();\n      }\n    });\n\n    _defineProperty(this, \"_defaultDataWriteDescriptorBuilders\", lodash_zipObject__WEBPACK_IMPORTED_MODULE_12___default()(this._defaultWriteOps, lodash_map__WEBPACK_IMPORTED_MODULE_9___default()(this._defaultWriteOps, function (actionName) {\n      return function (fullName, _configNode, pathDescriptor) {\n        var configNode;\n\n        if (actionName === 'set' && _configNode.writer) {\n          // custom settings\n          // TODO: this is not handled very well now is it...\n          configNode = _configNode.writer;\n        } else {\n          configNode = _configNode;\n        }\n\n        var metaCfg = _this._buildMetaWriteCfg(configNode, actionName, 'onWrite');\n\n        var customPathDescriptorBuilder = _this._customWritePathDescriptors[actionName];\n\n        if (customPathDescriptorBuilder) {\n          // push has a special path\n          pathDescriptor = customPathDescriptorBuilder(pathDescriptor);\n\n          if (!pathDescriptor) {\n            // this path does not have a sensical writer for this action (e.g. pushing to root)\n            return null;\n          }\n        }\n\n        return new _DataWriteDescriptor__WEBPACK_IMPORTED_MODULE_3__[\"default\"](pathDescriptor, metaCfg, fullName);\n      };\n    })));\n\n    this._dataProviders = dataProviders;\n    this._dataStructureCfgRoot = Object(_DataStructureConfig__WEBPACK_IMPORTED_MODULE_0__[\"parseConfig\"])(dataStructureCfgRaw);\n    this._plugins = plugins;\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14___default()(this);\n  } // #########################################################################\n  // public book keeping\n  // #########################################################################\n\n\n  _createClass(DataSourceTree, [{\n    key: \"getDataProvider\",\n    value: function getDataProvider(name) {\n      return this._dataProviders[name];\n    } // isNameLoaded(sourceName, args) {\n    //   const node = this.resolveName(sourceName);\n    //   if (!node) {\n    //     throw new Error('invalid node name: ' + sourceName);\n    //   }\n    //   return !node.isDataLoaded(args);\n    // }\n\n  }, {\n    key: \"getNodeByName\",\n    value: function getNodeByName(name) {\n      if (this.hasReader(name)) {\n        return this.resolveReader(name);\n      }\n\n      if (this.hasWriter(name)) {\n        return this.resolveWriter(name);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasReader\",\n    value: function hasReader(name) {\n      return !!this._root._readDescendants[name];\n    }\n  }, {\n    key: \"hasWriter\",\n    value: function hasWriter(name) {\n      return !!this._root._writeDescendants[name];\n    }\n  }, {\n    key: \"resolveReader\",\n    value: function resolveReader(name) {\n      var node = this._root._readDescendants[name];\n\n      if (!node) {\n        console.error(\"Requested reader \\\"\".concat(name, \"\\\" does not exist in DataSourceTree - \") + '(' + Object.keys(this._root._readDescendants).join(', ') + ')');\n      }\n\n      return node;\n    }\n  }, {\n    key: \"resolveWriter\",\n    value: function resolveWriter(name) {\n      var node = this._root._writeDescendants[name];\n\n      if (!node) {\n        console.error(\"Requested writer \\\"\".concat(name, \"\\\" does not exist in DataSourceTree - \") + '(' + Object.keys(this._root._writeDescendants).join(', ') + ')');\n      }\n\n      return node;\n    }\n  }, {\n    key: \"getAllReaderNames\",\n    value: function getAllReaderNames() {\n      return Object.keys(this._root._readDescendants);\n    }\n  }, {\n    key: \"getAllWriterNames\",\n    value: function getAllWriterNames() {\n      return Object.keys(this._root._writeDescendants);\n    }\n  }, {\n    key: \"_notifyPlugins\",\n    value: function _notifyPlugins(type) {\n      var _this2 = this;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      // TODO: replace with event engine instead?\n      //console.warn('DataSourceTree._notifyPlugins', type);\n      var plugins = this.getPlugins(type);\n\n      if (plugins) {\n        if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_7___default()(plugins)) {\n          var pluginFn = plugins;\n\n          this._notifyPlugin.apply(this, [type, pluginFn].concat(args));\n        } else if (lodash_isArray__WEBPACK_IMPORTED_MODULE_5___default()(plugins)) {\n          lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default()(plugins, function (pluginFn) {\n            return _this2._notifyPlugin.apply(_this2, [type, pluginFn].concat(args));\n          });\n        } else {\n          throw new Error(\"invalid plugin(s) of type '\".concat(type, \"' must be function or array of function: \").concat(plugins));\n        }\n      }\n    }\n  }, {\n    key: \"_notifyPlugin\",\n    value: function _notifyPlugin(type, pluginFn) {\n      try {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        var res = pluginFn.apply(void 0, args);\n\n        if (res !== undefined) {\n          var arr = this._pluginInstances[type] || (this._pluginInstances[type] = []);\n          arr.push(res);\n        }\n      } catch (err) {\n        throw new Error(\"ERROR when executing plugin of type '\".concat(type, \"' - \") + err.stack);\n      }\n    }\n  }, {\n    key: \"getPlugins\",\n    value: function getPlugins(type) {\n      return this._plugins[type];\n    }\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(type, readerOrPluginName) {\n      if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_7___default()(readerOrPluginName)) {\n        return readerOrPluginName;\n      } else if (lodash_isString__WEBPACK_IMPORTED_MODULE_6___default()(readerOrPluginName)) {\n        var name = readerOrPluginName;\n        var plugins = this.getPlugins(type);\n        var plugin = plugins && plugins[name];\n\n        if (!plugin) {\n          throw new Error(\"Could not find plugin of type \\\"\".concat(type, \"\\\" and name \\\"\").concat(name, \"\\\"\"));\n        }\n\n        return plugin;\n      } else {\n        throw new Error(\"Invalid config entry of type \\\"\".concat(type, \"\\\" must be function or string: \") + readerOrPluginName);\n      }\n    } // #########################################################################\n    // Methods for modifying the tree\n    // #########################################################################\n\n    /**\n     * WARNING: This does not perform a merge. Replaces any existing nodes in the hierarchy in case of name conflict.\n     */\n\n  }, {\n    key: \"addChildrenToRoot\",\n    value: function addChildrenToRoot(childrenCfgRaw) {\n      var root = this._root; //const childrenCfg = parseConfigChildren(root.cfg, childrenCfgRaw);\n\n      var childrenCfg = Object(_DataStructureConfig__WEBPACK_IMPORTED_MODULE_0__[\"parseConfigChildren\"])(null, childrenCfgRaw);\n\n      var newChildren = this._buildChildren(root, childrenCfg); // build\n\n\n      this._addChildrenToNode(root, newChildren); // add\n\n\n      return newChildren;\n    }\n  }, {\n    key: \"addChildToRoot\",\n    value: function addChildToRoot(name, childCfgRaw) {\n      this.addChildrenToRoot(_defineProperty({}, name, childCfgRaw));\n    } // #########################################################################\n    // Tree construction\n    // #########################################################################\n\n  }, {\n    key: \"_buildTree\",\n    value: function _buildTree() {\n      var cfg = this._dataStructureCfgRoot; // build tree\n\n      this._root = this._buildRoot(cfg); // add special nodes\n\n      this._addSpecialNodes(); // we need to compress once s.t. that plugins (such as DataRelationshipGraph) get full tree functionality\n\n\n      this._compressHierarchy(this._root); // add relationships and do other plugin stuff\n\n\n      this._notifyTreeBuilt(); // we need to compress a second time because plugins (such as DataRelationshipGraph) \n      //    might have added new nodes that are yet compressed\n\n\n      this._compressHierarchy(this._root);\n    }\n  }, {\n    key: \"_addSpecialNodes\",\n    value: function _addSpecialNodes() {\n      var _this3 = this;\n\n      this.addChildrenToRoot({\n        // special node: get instance of the tree itself\n        _tree: {\n          reader: function reader() {\n            return _this3;\n          }\n        },\n        _rawDataProviderAction: {\n          writer: function writer(_ref) {\n            var dataProviderName = _ref.dataProvider,\n                action = _ref.action,\n                remotePath = _ref.remotePath,\n                val = _ref.val;\n            var dataProvider = _this3._dataProviders[dataProviderName];\n\n            if (!dataProvider) {\n              throw new Error('invalid dataProviderName: ' + dataProviderName);\n            }\n\n            if (!dataProvider.actions[action]) {\n              throw new Error('invalid actionName: ' + action);\n            }\n\n            return dataProvider.actions[action](remotePath, val);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_notifyTreeBuilt\",\n    value: function _notifyTreeBuilt() {\n      this._notifyPlugins('tree', this);\n    }\n    /**\n     * Build the given node, as well as all readers/writers/children\n     */\n\n  }, {\n    key: \"_buildRoot\",\n    value: function _buildRoot(configNode) {\n      var newDataNode = this._buildNodeOnly(configNode, null, '', null, null);\n\n      this._buildAllDescendants(newDataNode, configNode);\n\n      return newDataNode;\n    }\n    /**\n     * Build readers/writers/children and add to existing node\n     */\n\n  }, {\n    key: \"_buildAllDescendants\",\n    value: function _buildAllDescendants(dataNode, configNode) {\n      var newChildren = Object.assign(this._buildReaders(dataNode, configNode.readers), this._buildWriters(dataNode, configNode.writers), this._buildChildren(dataNode, configNode.children)); // assign to _children\n\n      this._addChildrenToNode(dataNode, newChildren);\n\n      return newChildren;\n    }\n  }, {\n    key: \"_addChildrenToNode\",\n    value: function _addChildrenToNode(dataNode, dataChildNodes) {\n      dataNode._children = dataNode._children || {};\n      Object.assign(dataNode._children, dataChildNodes);\n    }\n    /**\n     * Create new node\n     */\n\n  }, {\n    key: \"_buildNodeOnly\",\n    value: function _buildNodeOnly(configNode, parent, name, buildDataReadDescriptor, buildDataWriteDescriptor) {\n      var dataProvider = this._dataProviders[configNode.dataProviderName];\n\n      if (configNode.dataProviderName && !dataProvider) {\n        throw new Error(\"Invalid dataProvider does not exist in node \\\"\".concat(name, \"\\\": \\\"\").concat(configNode.dataProviderName, \"\\\"\"));\n      }\n\n      var fullName = (parent && parent.fullName && parent.fullName + '.' || '') + name;\n      var pathDescriptor = configNode.pathConfig && new _PathDescriptor__WEBPACK_IMPORTED_MODULE_1__[\"default\"](parent && parent.pathDescriptor, configNode.pathConfig, fullName);\n      return new _DataSourceNode__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this, configNode, parent, dataProvider, name, fullName, pathDescriptor, buildDataReadDescriptor && buildDataReadDescriptor(fullName, configNode, pathDescriptor), buildDataWriteDescriptor && buildDataWriteDescriptor(fullName, configNode, pathDescriptor));\n    }\n  }, {\n    key: \"_buildDataReadDescriptor\",\n    value: function _buildDataReadDescriptor(fullName, configNode, pathDescriptor) {\n      var reader = configNode.reader,\n          fetch = configNode.fetch;\n      reader = reader && this.getPlugin('reader', reader);\n      var isReader = reader || pathDescriptor;\n      var readDescriptor = isReader && new _DataReadDescriptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](pathDescriptor, reader, fetch, fullName);\n      return readDescriptor;\n    }\n  }, {\n    key: \"_buildDataReadForceDescriptor\",\n    value: function _buildDataReadForceDescriptor(fullName, configNode, pathDescriptor) {\n      var origDescriptor = this._buildDataReadDescriptor(fullName, configNode, pathDescriptor);\n\n      var reader = function reader() {\n        if (!origDescriptor.isDataLoaded.apply(origDescriptor, arguments)) {\n          throw new Error('Force read failed. Data not loaded yet at data node: ' + fullName);\n        }\n\n        return origDescriptor.readData.apply(origDescriptor, arguments);\n      };\n\n      var fetch = origDescriptor.fetch;\n      return new _DataReadDescriptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](null, reader, fetch, fullName);\n    }\n  }, {\n    key: \"_buildDataIsLoadedReadDescriptor\",\n    value: function _buildDataIsLoadedReadDescriptor(fullName, configNode, pathDescriptor) {\n      var origDescriptor = this._buildDataReadDescriptor(fullName, configNode, pathDescriptor);\n\n      var reader = function reader() {\n        return origDescriptor.isDataLoaded.apply(origDescriptor, arguments);\n      };\n\n      var fetch = origDescriptor.fetch;\n      return new _DataReadDescriptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](null, reader, fetch, fullName);\n    }\n  }, {\n    key: \"_buildChildren\",\n    value: function _buildChildren(parent, cfgChildren) {\n      var _this4 = this;\n\n      // nodes that potentially have both readers and writers\n      var newNodes = {};\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default()(cfgChildren, function (configNode, name) {\n        // build node (actual buildNode() call)\n        var newDataNode = newNodes[name] = _this4._buildNodeOnly(configNode, parent, name, _this4._buildDataReadDescriptor, _this4._buildCustomDataSetDescriptor); // HACKFIX: there is certain properties of the original configNode that derivatives should not hang on to\n\n\n        configNode = _objectSpread({}, configNode);\n        delete configNode.hasMany;\n\n        if (configNode.pathConfig) {\n          // build default writers at path\n          _this4._buildDefaultWriters(configNode, parent, name, newNodes);\n        } else if (newDataNode.isWriter) {\n          // has no path, but has custom writer\n          var writerName = 'set_' + name;\n\n          _this4._buildDataWriteNode(configNode, parent, writerName, _this4._buildCustomDataSetDescriptor, newNodes);\n        }\n\n        if (newDataNode.isReader) {\n          // also register under the \"get_*\" alias\n          var readerName = 'get_' + name;\n          newNodes[readerName] = _this4._buildNodeOnly(configNode, parent, readerName, _this4._buildDataReadDescriptor, null); // add isLoaded node\n\n          readerName = name + '_isLoaded';\n          newNodes[readerName] = _this4._buildDataReadDescriptor && _this4._buildNodeOnly(configNode, parent, readerName, _this4._buildDataIsLoadedReadDescriptor, null); // add the \"force_*\" reader\n\n          readerName = 'force_' + name;\n          newNodes[readerName] = _this4._buildNodeOnly(configNode, parent, readerName, _this4._buildDataReadForceDescriptor, null);\n        } // recurse\n\n\n        _this4._buildAllDescendants(newDataNode, configNode);\n      });\n      return newNodes;\n    }\n  }, {\n    key: \"_buildReaders\",\n    value: function _buildReaders(parent, readers) {\n      var _this5 = this;\n\n      return lodash_mapValues__WEBPACK_IMPORTED_MODULE_10___default()(readers, function (configNode, name) {\n        var newDataNode = _this5._buildNodeOnly(configNode, parent, name, _this5._buildDataReadDescriptor, null);\n\n        return newDataNode;\n      });\n    } // #############################################\n    // Handle Writers\n    //\n    // TODO: Consider moving DataProvider-dependent stuff outta here\n    // ##############################################\n\n  }, {\n    key: \"_buildDefaultWriters\",\n    value: function _buildDefaultWriters(configNode, parent, name, newNodes) {\n      var _this6 = this;\n\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default()(this._defaultDataWriteDescriptorBuilders, function (descriptorBuilder, writerName) {\n        _this6._buildDataWriteNode(configNode, parent, writerName + '_' + name, descriptorBuilder, newNodes);\n      });\n    }\n  }, {\n    key: \"_buildMetaWriteCfg\",\n    value: function _buildMetaWriteCfg(configNode, actionName, eventName) {\n      var _this7 = this;\n\n      var onWrite = configNode[eventName];\n\n      if (lodash_isArray__WEBPACK_IMPORTED_MODULE_5___default()(onWrite)) {\n        // get final set of functions for each function\n        var fns = lodash_map__WEBPACK_IMPORTED_MODULE_9___default()(onWrite, function (cfg) {\n          return _this7.getPlugin(eventName, cfg);\n        }); // nest function calls\n\n        onWrite = function onWrite() {\n          for (var i = 0; i < fns.length; ++i) {\n            fns[i].apply(fns, arguments);\n          }\n        };\n      } else {\n        onWrite = onWrite && this.getPlugin(eventName, onWrite);\n      }\n\n      return {\n        actionName: actionName,\n        onWrite: onWrite\n      };\n    }\n    /**\n     * functions to create DataWriteScriptor for each write action.\n     */\n\n  }, {\n    key: \"_buildCustomDataSetDescriptor\",\n    value: function _buildCustomDataSetDescriptor(fullName, configNode, _) {\n      var metaCfg = this._buildMetaWriteCfg(configNode, 'custom', 'onWrite');\n\n      return configNode.writer && new _DataWriteDescriptor__WEBPACK_IMPORTED_MODULE_3__[\"default\"](configNode.writer, metaCfg, fullName);\n    }\n  }, {\n    key: \"_buildDataWriteNode\",\n    value: function _buildDataWriteNode(configNode, parent, name, descriptorBuilder, newChildren) {\n      var newDataNode = this._buildNodeOnly(configNode, parent, name, null, descriptorBuilder);\n\n      return newChildren[name] = newDataNode;\n    }\n  }, {\n    key: \"_buildWriters\",\n    value: function _buildWriters(parent, writers) {\n      var _this8 = this;\n\n      var newChildren = {};\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default()(writers, function (configNode, name) {\n        _this8._buildDataWriteNode(configNode, parent, name, _this8._buildCustomDataSetDescriptor, newChildren);\n      });\n      return newChildren;\n    } // #########################################################################\n    // Descendant management + hierarchy compression\n    // #########################################################################\n\n  }, {\n    key: \"_addDescendants\",\n    value: function _addDescendants(descendants, childDescendants) {\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default()(childDescendants, function (descendant, name) {\n        if (!descendants[name]) {\n          descendants[name] = descendant;\n        } else {\n          // ambiguous!\n          var originalNode = descendants[name];\n          var ambiguousNode;\n\n          if (!(originalNode instanceof _DataSourceNode__WEBPACK_IMPORTED_MODULE_4__[\"AmbiguousSourceNode\"])) {\n            descendants[name] = ambiguousNode = new _DataSourceNode__WEBPACK_IMPORTED_MODULE_4__[\"AmbiguousSourceNode\"](name, originalNode.fullName);\n          } else {\n            ambiguousNode = originalNode;\n          }\n\n          ambiguousNode.fullNames.push(descendant.fullName);\n        }\n      });\n    }\n  }, {\n    key: \"_addImmediateDescendants\",\n    value: function _addImmediateDescendants(descendants, node, filter) {\n      // immediate children always have top priority\n      // override any other node in case of ambiguity\n      var children = lodash_pickBy__WEBPACK_IMPORTED_MODULE_11___default()(node._children, filter);\n      Object.assign(descendants, children);\n    }\n    /**\n     * Copy all non-conflicting descendant (lower-level) nodes into all ascendant (upper-level) nodes' children, all the way back into the root\n     * \n     * @param {*} node \n     */\n\n  }, {\n    key: \"_compressHierarchy\",\n    value: function _compressHierarchy(node) {\n      var _this9 = this;\n\n      var readDescendants = {};\n      var writeDescendants = {};\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_8___default()(node._children, function (child) {\n        // recurse: compress children first\n        _this9._compressHierarchy(child); // on the way back up, build sets of descendants\n\n\n        _this9._addDescendants(readDescendants, child._readDescendants);\n\n        _this9._addDescendants(writeDescendants, child._writeDescendants);\n      }); // merge immediate children into node's descendant sets\n\n      this._addImmediateDescendants(readDescendants, node, function (childNode) {\n        return childNode.isReader;\n      });\n\n      node._readDescendants = readDescendants;\n\n      this._addImmediateDescendants(writeDescendants, node, function (childNode) {\n        return childNode.isWriter;\n      });\n\n      node._writeDescendants = writeDescendants;\n    }\n    /**\n     * @returns {DataAccessTracker}\n     */\n\n  }, {\n    key: \"newAccessTracker\",\n    value: function newAccessTracker(name, listener) {\n      return new _DataAccessTracker__WEBPACK_IMPORTED_MODULE_15__[\"default\"](this, listener, name);\n    }\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this._root;\n    }\n  }]);\n\n  return DataSourceTree;\n}();\n\n//# sourceURL=webpack://dbdi/./DataSourceTree.js?");

/***/ }),

/***/ "./DataStructureConfig.js":
/*!********************************!*\
  !*** ./DataStructureConfig.js ***!
  \********************************/
/*! exports provided: parseConfig, default, parseConfigChildren, DataStructureConfigNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseConfig\", function() { return parseConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataStructureConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseConfigChildren\", function() { return parseConfigChildren; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataStructureConfigNode\", function() { return DataStructureConfigNode; });\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/map */ \"../node_modules/lodash/map.js\");\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/mapValues */ \"../node_modules/lodash/mapValues.js\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEmpty */ \"../node_modules/lodash/isEmpty.js\");\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var lodash_intersection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/intersection */ \"../node_modules/lodash/intersection.js\");\n/* harmony import */ var lodash_intersection__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_intersection__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var src_util_pathUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! src/util/pathUtil */ \"./util/pathUtil.js\");\n/* harmony import */ var src_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! src/util */ \"./util/index.js\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\nfunction parseConfig(cfg) {\n  if (cfg instanceof DataStructureConfig) {\n    // already parsed!\n    return cfg;\n  } // raw configuration input\n\n\n  return new DataStructureConfig(cfg);\n}\n\nvar DataStructureConfig = function DataStructureConfig(cfg) {\n  _classCallCheck(this, DataStructureConfig);\n\n  _defineProperty(this, \"children\", void 0);\n\n  this.children = parseConfigChildren(null, cfg);\n};\n\n\nfunction parseConfigChildren(parent, children) {\n  if (parent !== null && !(parent instanceof DataStructureConfigNode)) {\n    debugger;\n    throw new Error('invalid configuration: parent must be null or an instance of `DataStructureConfigNode`');\n  }\n\n  return lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default()(children || src_util__WEBPACK_IMPORTED_MODULE_8__[\"EmptyObject\"], function (childCfg, name) {\n    return childCfg instanceof DataStructureConfigNode ? childCfg : new DataStructureConfigNode(name, parent, childCfg);\n  });\n}\n/**\n * A parsed \"dataConfig\" object.\n * Allows composing of local descriptors built from descriptors imported from other places.\n */\n\nvar DataStructureConfigNode =\n/*#__PURE__*/\nfunction () {\n  /**\n   * This node's (or the parent's) dataProvider name\n   */\n\n  /**\n   * The path configuration of this node.\n   * \n   * @type {object}\n   * @property {string} pathTemplate The pathTemplate string\n   * @property {array} queryParams Additional arguments passed to the query of this path\n   * @property {function} pathFn A function to build the path at run-time and override the path template setting\n   */\n\n  /**\n   * Whether this node has been explicitly configured as read-only.\n   */\n\n  /**\n   * A custom reader configuration for this node.\n   * Will simply use the pathConfig to create a reader if none is given.\n   */\n\n  /**\n   * A fetch function to be called when this node is read but not loaded yet.\n   * This can be used to un API calls to fetch data on first read, which\n   * then stays cached in this node.\n   * Only useful in combination with DataProviders that do not have their own\n   * backend handling mechanism, such as MemoryDataProvider.\n   * \n   * TODO: Allow for more configuration parameters to automatically identify stale data\n   */\n  // TODO: writeThrough (can probably be done just fine using a combination of onWrite + fetch?)\n\n  /**\n   * A custom writer configuration for this node.\n   * Will simply use the pathConfig to create writer if none is given.\n   */\n\n  /**\n   * Called to make modifications to written object\n   */\n  function DataStructureConfigNode(name, parent, cfg) {\n    _classCallCheck(this, DataStructureConfigNode);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"children\", {});\n\n    _defineProperty(this, \"dataProviderName\", void 0);\n\n    _defineProperty(this, \"pathConfig\", void 0);\n\n    _defineProperty(this, \"isReadOnly\", void 0);\n\n    _defineProperty(this, \"reader\", void 0);\n\n    _defineProperty(this, \"fetch\", void 0);\n\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"onWrite\", void 0);\n\n    this.name = name;\n    this.parent = parent;\n    cfg !== null && cfg !== undefined || console.error('DataStructureConfig missing config object:', name, parent);\n\n    this._parseConfig(cfg);\n  } // ################################################\n  // Private methods\n  // ################################################\n\n\n  _createClass(DataStructureConfigNode, [{\n    key: \"_parseConfig\",\n    value: function _parseConfig(cfg) {\n      if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_4___default()(cfg)) {\n        // path transformation function\n        this._parsePath(cfg, cfg);\n\n        this._ensureDataProvider(cfg);\n      } else if (lodash_isString__WEBPACK_IMPORTED_MODULE_3___default()(cfg)) {\n        // path string\n        this._parsePath(cfg, cfg);\n\n        this._ensureDataProvider(cfg);\n      } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default()(cfg)) {\n        // more complex descriptor node\n        //Object.assign(this, cfg);\n        // TODO: hasMany, relationship stuff and a lot of other customizations should be entirely be handled from the outside (via Plugin mechanics)\n        this.hasMany = cfg.hasMany;\n        this.isReadOnly = cfg.isReadOnly || false;\n\n        this._parsePath(cfg, cfg.path !== undefined ? cfg.path : cfg.pathTemplate);\n\n        this._parseReader(cfg);\n\n        this._parseFetch(cfg);\n\n        this._parseWriter(cfg);\n\n        this.dataProviderName = cfg.dataProvider;\n\n        this._ensureDataProvider(cfg); // parse children and recurse, once this node has been taken care of\n\n\n        this._parseChildren(cfg); // parse \"readers\" and \"writers\" (and add them to children)\n\n\n        this._parseReaders(cfg);\n\n        this._parseWriters(cfg);\n      } else {\n        throw new Error('could not parse invalid config object: ' + this.name);\n      }\n    }\n  }, {\n    key: \"_ensureDataProvider\",\n    value: function _ensureDataProvider(cfg) {\n      this.dataProviderName = this.dataProviderName || this.parent && this.parent.dataProviderName;\n\n      if (this.parent && this.pathConfig && !this.dataProviderName) {\n        console.error(this.parent, '>', this.name);\n        throw new Error('Missing dataProvider in config: ' + this.name + ' - ' + JSON.stringify(cfg, null, 2));\n      }\n    }\n  }, {\n    key: \"_parsePath\",\n    value: function _parsePath(cfg, pathConfig) {\n      var parent = this.parent;\n      var parentPath = parent && parent.pathConfig && parent.pathConfig.pathTemplate || '';\n\n      if (pathConfig === null || pathConfig === undefined) {\n        if (!cfg || !cfg.children) {\n          this.pathConfig = null;\n          return;\n        } else {\n          pathConfig = '';\n        }\n      }\n\n      var pathTemplate;\n      var queryParams = null;\n      var indices = null;\n      var pathFn = null;\n\n      if (lodash_isString__WEBPACK_IMPORTED_MODULE_3___default()(pathConfig)) {\n        pathTemplate = pathConfig;\n      } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default()(pathConfig)) {\n        pathTemplate = pathConfig.path || pathConfig.pathTemplate;\n        queryParams = pathConfig.queryParams;\n        indices = pathConfig.indices;\n      }\n\n      if (!lodash_isString__WEBPACK_IMPORTED_MODULE_3___default()(pathTemplate)) {\n        if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_4___default()(pathTemplate)) {\n          pathFn = pathTemplate;\n        }\n\n        pathTemplate = '';\n      } // join with parent path\n\n\n      var localPathTemplate = pathTemplate;\n      pathTemplate = Object(src_util_pathUtil__WEBPACK_IMPORTED_MODULE_7__[\"pathJoin\"])(parentPath, pathTemplate);\n      this.pathConfig = {\n        pathTemplate: pathTemplate,\n        localPathTemplate: localPathTemplate,\n        queryParams: queryParams,\n        indices: indices,\n        pathFn: pathFn\n      };\n    }\n  }, {\n    key: \"_checkSpecializedChildrenStructure\",\n    value: function _checkSpecializedChildrenStructure(children, otherChildren, childrenName) {\n      // want a plain object\n      console.assert(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_5___default()(otherChildren), \"invalid \\\"\".concat(childrenName, \"\\\" node is not plain object in DataStructureConfigNode: \") + this.name);\n\n      if (children) {\n        // check for naming conflict\n        var readerNames = Object.keys(otherChildren);\n        var childNames = Object.keys(children);\n        var overlap = lodash_intersection__WEBPACK_IMPORTED_MODULE_6___default()(readerNames, childNames);\n\n        if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2___default()(overlap)) {\n          throw new Error(\"invalid \\\"\".concat(childrenName, \"\\\" definitions have name conflict with \") + \"\\\"children\\\" in DataStructureConfigNode \\\"\".concat(this.name, \"\\\": \").concat(overlap.join(', '), \" exist in both\"));\n        }\n      }\n    }\n  }, {\n    key: \"_parseChildren\",\n    value: function _parseChildren(cfg) {\n      this.children = cfg.children && parseConfigChildren(this, cfg.children) || null;\n    }\n  }, {\n    key: \"_parseReader\",\n    value: function _parseReader(cfg) {\n      if (cfg.read || cfg.reader) {\n        // a custom reader for this node\n        this.reader = cfg.read || cfg.reader;\n      }\n    }\n  }, {\n    key: \"_parseFetch\",\n    value: function _parseFetch(cfg) {\n      //if (cfg.fetch) {\n      // a custom reader for this node\n      this.fetch = cfg.fetch; //}\n    }\n  }, {\n    key: \"_parseReaders\",\n    value: function _parseReaders(cfg) {\n      var _this = this;\n\n      if (cfg.readers) {\n        // multiple readers that are actually children of this node\n        var readers = cfg.readers; // check for name conflict between \"readers\" and \"children\"\n\n        this._checkSpecializedChildrenStructure(this.children, readers, 'readers'); // add reader-only children\n\n\n        var readerNodes = lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default()(readers, function (reader, name) {\n          return new DataStructureConfigNode(name, _this, {\n            reader: reader\n          });\n        });\n        this.children = Object.assign({}, this.children, readerNodes);\n      }\n    }\n  }, {\n    key: \"_parseWriter\",\n    value: function _parseWriter(cfg) {\n      if (cfg.write || cfg.writer) {\n        // a custom writer for this node\n        this.writer = cfg.write || cfg.writer;\n      }\n\n      this.onWrite = cfg.onWrite;\n    }\n  }, {\n    key: \"_parseWriters\",\n    value: function _parseWriters(cfg) {\n      var _this2 = this;\n\n      if (cfg.writers) {\n        // multiple writers that are actually children of this node\n        var writers = cfg.writers; // check for name conflict between \"readers\" and \"children\"\n\n        this._checkSpecializedChildrenStructure(this.children, writers, 'writers'); // add writer-only children\n\n\n        var writerNodes = lodash_mapValues__WEBPACK_IMPORTED_MODULE_1___default()(writers, function (writer, name) {\n          return new DataStructureConfigNode(name, _this2, {\n            writer: writer\n          });\n        });\n        this.children = Object.assign({}, this.children, writerNodes);\n      }\n    }\n  }]);\n\n  return DataStructureConfigNode;\n}();\n\n//# sourceURL=webpack://dbdi/./DataStructureConfig.js?");

/***/ }),

/***/ "./dataProviders/MemoryDataProvider.js":
/*!*********************************************!*\
  !*** ./dataProviders/MemoryDataProvider.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MemoryDataProvider; });\n/* harmony import */ var _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dataProviders/DataProviderBase */ \"./dataProviders/DataProviderBase.js\");\n/* harmony import */ var src_util_pathUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/util/pathUtil */ \"./util/pathUtil.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/map */ \"../node_modules/lodash/map.js\");\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var uuid_v1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid/v1 */ \"../node_modules/uuid/v1.js\");\n/* harmony import */ var uuid_v1__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(uuid_v1__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _PathUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../PathUtil */ \"./PathUtil.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Read/write data to/from memory\n */\n\n\n\n\n\n\n\n\n\nvar MemoryDataProvider =\n/*#__PURE__*/\nfunction (_DataProviderBase) {\n  _inherits(MemoryDataProvider, _DataProviderBase);\n\n  function MemoryDataProvider() {\n    var _this;\n\n    _classCallCheck(this, MemoryDataProvider);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MemoryDataProvider).call(this));\n\n    _defineProperty(_assertThisInitialized(_this), \"actions\", {\n      set: function set(remotePath, val) {\n        _this._onWrite('Set', remotePath, val);\n\n        return Promise.resolve(true);\n      },\n\n      /**\n       * (somewhat) mimics Firebase push behavior\n       * @see https://firebase.google.com/docs/reference/js/firebase.database.Reference#push\n       */\n      push: function push(remotePath, val) {\n        var key = uuid_v1__WEBPACK_IMPORTED_MODULE_6___default()();\n        var promise = Promise.resolve(true);\n        promise.key = key; //console.log('push', pathJoin(remotePath, key), val);\n\n        _this._onWrite('Pus', Object(src_util_pathUtil__WEBPACK_IMPORTED_MODULE_1__[\"pathJoin\"])(remotePath, key), val);\n\n        return promise;\n      },\n      update: function update(remotePath, val) {\n        lodash_map__WEBPACK_IMPORTED_MODULE_3___default()(val, function (v, k) {\n          return _this._onWrite('Upd', Object(src_util_pathUtil__WEBPACK_IMPORTED_MODULE_1__[\"pathJoin\"])(remotePath, k), v);\n        });\n        return Promise.resolve(true);\n      },\n      delete: function _delete(remotePath) {\n        var data = _this.readData(remotePath);\n\n        if (data !== null) {\n          // deleted it\n          _this._onWrite('Del', remotePath, null);\n\n          return Promise.resolve(true);\n        } else {\n          // nothing to do\n          return Promise.resolve(false);\n        }\n      } // transaction: () => {\n      //   // TODO\n      // },\n      // batchUpdate: () => {\n      //   // TODO\n      // }\n\n    });\n\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5___default()(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * TODO: Memory data provider might be used for different purposes.\n   *  e.g.: fetchGood vs. \n   * When acting as a cache for a remote API, isDataFullyAvailable \n   * behaves like it would for a remote DataProvider.\n   * When just storing some local values, this should just return true.\n   * Path configuration should decide!\n   */\n  // isDataFullyAvailable() {\n  //   return true;\n  // }\n  // #################################################################\n  // Any DataProvider can/needs to implement the following methods\n  // #################################################################\n\n\n  _createClass(MemoryDataProvider, [{\n    key: \"fetchOnce\",\n    value: function () {\n      var _fetchOnce = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", null);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetchOnce() {\n        return _fetchOnce.apply(this, arguments);\n      }\n\n      return fetchOnce;\n    }()\n    /**\n     * A listener started listening on a path for the fast time\n     */\n\n  }, {\n    key: \"onPathListenStart\",\n    value: function onPathListenStart(query, listener) {}\n  }, {\n    key: \"onPathListenEnd\",\n    value: function onPathListenEnd(query, customData) {}\n  }, {\n    key: \"_onWrite\",\n    value: function _onWrite(action, remotePath, val) {\n      console.log('W [', action, remotePath, '] ', val); // NOTE: local and remote path are equal for the MemoryDataProvider (for now)\n\n      var query = this.getOrCreateQuery(remotePath);\n      this.notifyNewData(query, val); // TODO: untested\n      // propagate to all ancestors that have listeners (Firebase does this, too)\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Object(_PathUtil__WEBPACK_IMPORTED_MODULE_7__[\"getAllAncestorNodesInPath\"])(remotePath)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var path = _step.value;\n\n          var _query = this.getOrCreateQuery(path);\n\n          var localPath = _query.localPath;\n\n          var _val = Object(_PathUtil__WEBPACK_IMPORTED_MODULE_7__[\"getDataIn\"])(this._cache, localPath);\n\n          this.notifyNewData(_query, _val);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return MemoryDataProvider;\n}(_dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://dbdi/./dataProviders/MemoryDataProvider.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: NOT_LOADED, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataProviders/DataProviderBase */ \"./dataProviders/DataProviderBase.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NOT_LOADED\", function() { return _dataProviders_DataProviderBase__WEBPACK_IMPORTED_MODULE_0__[\"NOT_LOADED\"]; });\n\n/* harmony import */ var _DataSourceTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataSourceTree */ \"./DataSourceTree.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_DataSourceTree__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n//# sourceURL=webpack://dbdi/./index.js?");

/***/ }),

/***/ "./plugins/DataRelationshipGraph.js":
/*!******************************************!*\
  !*** ./plugins/DataRelationshipGraph.js ***!
  \******************************************/
/*! exports provided: DataRelationshipGraph, DataRelationshipPlugin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataRelationshipGraph\", function() { return DataRelationshipGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataRelationshipPlugin\", function() { return DataRelationshipPlugin; });\n/* harmony import */ var lodash_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/size */ \"../node_modules/lodash/size.js\");\n/* harmony import */ var lodash_size__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_size__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/filter */ \"../node_modules/lodash/filter.js\");\n/* harmony import */ var lodash_filter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_filter__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_every__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/every */ \"../node_modules/lodash/every.js\");\n/* harmony import */ var lodash_every__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_every__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/forEach */ \"../node_modules/lodash/forEach.js\");\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/map */ \"../node_modules/lodash/map.js\");\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/mapValues */ \"../node_modules/lodash/mapValues.js\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isArray */ \"../node_modules/lodash/isArray.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var lodash_zipObject__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/zipObject */ \"../node_modules/lodash/zipObject.js\");\n/* harmony import */ var lodash_zipObject__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_zipObject__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/times */ \"../node_modules/lodash/times.js\");\n/* harmony import */ var lodash_times__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash_times__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var lodash_uniq__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/uniq */ \"../node_modules/lodash/uniq.js\");\n/* harmony import */ var lodash_uniq__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(lodash_uniq__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/merge */ \"../node_modules/lodash/merge.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! pluralize */ \"../node_modules/pluralize/pluralize.js\");\n/* harmony import */ var pluralize__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(pluralize__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../util */ \"./util/index.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! .. */ \"./index.js\");\n/* harmony import */ var _PathUtil__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../PathUtil */ \"./PathUtil.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * many2many indexing (only working for Firebase-style data organization for now)\n * \n * TODO: Need more general approach for handling deletion.\n *     'deleteA' + 'deleteB' cannot be overridden for just one relationship, but it must consider all relationships it is participating in\n * \n * TODO: the newly inserted names might clash with existing ones - gotta fix (e.g. deletePresentationSession)\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //import { getOptionalArgument } from 'src/dbdi/dataAccessUtil';\n\n\n/**\n * ####################################################################################\n * Name management\n * \n * The overall naming scheme explained:\n *    -> \"a\" has many, \"b\" has 1\n *    -> \"a\" belongsTo \"b\", \"b\" hasMany \"a\"\n *    -> \"a\" is owned by \"b\", \"b\" owns \"a\"\n *    -> Example: a = 'user', b = 'project' => asOfB => usersOfProject\n * ####################################################################################\n */\n\n/**\n * We want the lower-case names (and capitalize the name ourselves).\n * For simplicity sake, we only work with alphanumerical names for now.\n */\n\nvar validNameRe = /[a-z_$][0-9a-zA-Z_$]*/;\n\nfunction capitalize(name) {\n  return name.replace(/(^|\\s)\\S/g, function (l) {\n    return l.toUpperCase();\n  });\n}\n\nvar _allNameProxies = {};\nvar _relationshipNameGenerators = {\n  asOfB: function asOfB(n) {\n    return \"\".concat(n.as, \"Of\").concat(n.B);\n  },\n  // (e.g. usersOfProject)\n  aIdsOfBs: function aIdsOfBs(n) {\n    return \"\".concat(n.aIds, \"Of\").concat(n.Bs);\n  },\n  // (e.g. uidsOfProjects)\n  aIdsOfB: function aIdsOfB(n) {\n    return \"\".concat(n.aIds, \"Of\").concat(n.B);\n  },\n  // (e.g. uidsOfProject)\n  aIdOfB: function aIdOfB(n) {\n    return \"\".concat(n.aId, \"Of\").concat(n.B);\n  },\n  // (e.g. uidOfProject)\n  countAsOfB: function countAsOfB(n) {\n    return \"count\".concat(n.As, \"Of\").concat(n.B);\n  },\n  // (e.g. countUsersOfProject)\n  anyAsOfB: function anyAsOfB(n) {\n    return \"any\".concat(n.As, \"Of\").concat(n.B);\n  },\n  // (e.g. anyUsersOfProject)\n  bIdsWithoutA: function bIdsWithoutA(n) {\n    return \"\".concat(n.bIds, \"Without\").concat(n.A);\n  },\n  // (e.g. projectIdsWithoutUser)\n  addAToB: function addAToB(n) {\n    return \"add\".concat(n.A, \"To\").concat(n.B);\n  },\n  deleteAFromB: function deleteAFromB(n) {\n    return \"delete\".concat(n.A, \"From\").concat(n.B);\n  },\n  deleteAllAsFromB: function deleteAllAsFromB(n) {\n    return \"deleteAll\".concat(n.As, \"From\").concat(n.B);\n  },\n  deleteA: function deleteA(n) {\n    return \"delete\".concat(n.A);\n  },\n  deleteB: function deleteB(n) {\n    return \"delete\".concat(n.B);\n  },\n  // update_aIdOfB: (n) => `update_${n.aIdOfB}`,\n  // update_aIdsOfB: (n) => `update_${n.aIdsOfB}`,\n  // update_aIdsOfBs: (n) => `update_${n.aIdsOfBs}`,\n  connectAB: function connectAB(n) {\n    return \"connect\".concat(n.A).concat(n.B);\n  },\n  disconnectAB: function disconnectAB(n) {\n    return \"disconnect\".concat(n.A).concat(n.B);\n  }\n};\nvar _nameProxyHandler = {\n  get: function get(obj, prop) {\n    var fn = _relationshipNameGenerators[prop];\n\n    if (fn) {\n      return fn(obj);\n    }\n\n    if (!obj[prop]) {\n      throw new Error(\"invalid name does not exist: \".concat(prop, \" for (\").concat(obj.toString(), \")\"));\n    }\n\n    return obj[prop];\n  }\n};\n/**\n * Generate names.\n */\n\nfunction _getNameProxy() {\n  for (var _len = arguments.length, allNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    allNames[_key] = arguments[_key];\n  }\n\n  var aName = allNames[0],\n      bName = allNames[1],\n      aIdName = allNames[2],\n      bIdName = allNames[3],\n      bListName = allNames[4];\n  var nameSetId = allNames.join('_');\n\n  if (_allNameProxies[nameSetId]) {\n    return _allNameProxies[nameSetId];\n  } // check if all names satisfy criteria\n\n\n  _validateNames([aName, bName, aIdName, bIdName]); // build all the names\n\n\n  var n = {\n    a: aName,\n    b: bName,\n    aId: aIdName,\n    bId: bIdName,\n    bList: bListName\n  };\n  Object.assign(n, {\n    A: capitalize(n.a),\n    B: capitalize(n.b),\n    AId: capitalize(n.aId),\n    BId: capitalize(n.bId),\n    as: pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.a),\n    bs: pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.b),\n    aIds: pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.aId),\n    bIds: pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.bId)\n  });\n  Object.assign(n, {\n    As: capitalize(pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.a)),\n    Bs: capitalize(pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.b)),\n    AIds: capitalize(pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.aId)),\n    BIds: capitalize(pluralize__WEBPACK_IMPORTED_MODULE_13___default()(n.bId))\n  }); // build proxy\n\n  var p = new Proxy(n, _nameProxyHandler);\n\n  n.toString = p.toString = function () {\n    return \"Names: \".concat(allNames.join(', '));\n  }; // cache proxy\n\n\n  _allNameProxies[nameSetId] = p;\n  return p;\n}\n\nfunction getRelationshipName(aName, bName) {\n  return [aName, bName].sort().join('_');\n}\n\nfunction _validateName(name) {\n  if (!validNameRe.test(name)) {\n    throw new Error(\"invalid name in data relationship: \".concat(name, \" - must be alphanumerical AND start lower-case!\"));\n  }\n\n  if (name === pluralize__WEBPACK_IMPORTED_MODULE_13___default()(name)) {\n    throw new Error(\"invalid name in data relationship: \".concat(name, \" - must be singular and different from it's own plural\"));\n  }\n}\n/**\n * Do some sanity checks on all names, to avoid naming conflicts.\n * This is because we will automatically generate all kinds of names automatically, and \n * that can get ugly real soon real fast.\n */\n\n\nfunction _validateNames(allNames) {\n  // overall criteria\n  if (lodash_uniq__WEBPACK_IMPORTED_MODULE_11___default()(allNames).length < allNames.length) {\n    throw new Error(\"invalid name in data relationship: \\\"\".concat(allNames.join(', '), \"\\\" - all names, and all variable (id) names all must be unique\"));\n  } // individual criteria\n\n\n  allNames.forEach(_validateName);\n}\n\nfunction pathForVar(varName) {\n  return \"$(\".concat(varName, \")\");\n}\n\nfunction getIdNameFromPathTemplate(pathTemplate) {\n  var idName = Object(_PathUtil__WEBPACK_IMPORTED_MODULE_17__[\"getFirstVariableInPathTemplate\"])(pathTemplate);\n\n  if (!idName) {\n    throw new Error(\"invalid \\\"hasMany\\\" relationship - can only be added to nodes with single variable in path: '\".concat(pathTemplate, \"'\") // +'- HINT: you can add \"indices\" to the node (possibly with isProperty set to false), to have a single variable represent multiple values'\n    );\n  }\n\n  return idName;\n}\n/**\n * ####################################################################################\n * Build data model\n * ####################################################################################\n */\n\n/** \n * Batch multiple write operations into a single update operation.\n * Will maintain an optional argument '_batchedUpdates', which carries the\n * wanted updates through any amount of write operations.\n * The given `generateUpdates` callback is an asynchronous call; once\n * it returns at the top level, will commit all updates to DB.\n * \n * TODO: does not currently work when using paths of different dataProviders.\n */\n\n\nfunction batchUpdate(_x, _x2, _x3, _x4) {\n  return _batchUpdate.apply(this, arguments);\n}\n/**\n * The config generated from this is added to any hasMany relationship.\n * Many2many relationships will add these once for each direction.\n */\n\n\nfunction _batchUpdate() {\n  _batchUpdate = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee15(args, writers, dataProvider, generateUpdates) {\n    var newUpdates, writeArgs;\n    return regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _context15.next = 2;\n            return generateUpdates(args);\n\n          case 2:\n            newUpdates = _context15.sent;\n            //Object.assign(_batchedUpdates, newUpdates);\n            //if (isFirstOnStack) {\n            // actually send out the updates\n            writeArgs = {\n              dataProvider: dataProvider,\n              action: 'update',\n              remotePath: '',\n              val: newUpdates\n            };\n            _context15.next = 6;\n            return writers._rawDataProviderAction(writeArgs);\n\n          case 6:\n            return _context15.abrupt(\"return\", _context15.sent);\n\n          case 7:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15, this);\n  }));\n  return _batchUpdate.apply(this, arguments);\n}\n\nvar basicDataModelGenerators = {\n  hasMany: function hasMany(n, dataProvider, cfg) {\n    var _readers;\n\n    return {\n      children: _defineProperty({}, n.aIdsOfBs, {\n        path: n.aIdsOfBs,\n        children: _defineProperty({}, n.aIdsOfB, {\n          path: pathForVar(n.bId),\n          reader: function reader(res) {\n            if (res === null) {\n              return _util__WEBPACK_IMPORTED_MODULE_15__[\"EmptyObject\"];\n            }\n\n            if (res === ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"]) {\n              return res;\n            }\n\n            console.assert(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_7___default()(res)); // this is an object of shape: {\n            //  id1: 1,\n            //  id2: null,\n            //  id3: 1\n            // }\n            // NOTE: value might be null!\n            //    indicating, the relationship got removed.\n\n            var keys = Object.keys(res).filter(function (k) {\n              return res[k];\n            });\n            return keys;\n          },\n          children: _defineProperty({}, n.aIdOfB, pathForVar(n.aId))\n        })\n      }),\n      readers: (_readers = {}, _defineProperty(_readers, n.asOfB, function (args, readers) {\n        var ids = readers[n.aIdsOfB](args);\n\n        if (ids === ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"]) {\n          return ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"];\n        }\n\n        return lodash_zipObject__WEBPACK_IMPORTED_MODULE_9___default()(ids || _util__WEBPACK_IMPORTED_MODULE_15__[\"EmptyArray\"], ids.map(function (id) {\n          return readers[n.a](_defineProperty({}, n.aId, id));\n        }));\n      }), _defineProperty(_readers, n.countAsOfB, function (args, readers) {\n        var ids = readers[n.aIdsOfB](args);\n\n        if (ids === ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"]) {\n          return ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"];\n        }\n\n        return lodash_size__WEBPACK_IMPORTED_MODULE_0___default()(ids);\n      }), _defineProperty(_readers, n.anyAsOfB, function (args, readers) {\n        var ids = readers[n.aIdsOfB](args);\n\n        if (ids === ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"]) {\n          return ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"];\n        }\n\n        return lodash_size__WEBPACK_IMPORTED_MODULE_0___default()(ids) > 0;\n      }), _defineProperty(_readers, n.bIdsWithoutA, function (args, readers) {\n        // WARNING: this doesn't scale well once there are many B's\n        var getAllBs = readers[n.bList];\n        var getAIdsOfB = readers[n.aIdsOfB];\n\n        if (!getAllBs.isLoaded(args)) {\n          return ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"];\n        }\n\n        var bs = getAllBs();\n\n        if (!bs) {\n          return _util__WEBPACK_IMPORTED_MODULE_15__[\"EmptyArray\"];\n        }\n\n        var bIds = Object.keys(bs);\n        var idArgs = lodash_map__WEBPACK_IMPORTED_MODULE_4___default()(bIds, function (bId) {\n          return _defineProperty({}, n.bId, bId);\n        });\n        var isLoaded = getAIdsOfB.areAllLoaded(idArgs);\n\n        if (!isLoaded) {\n          return ___WEBPACK_IMPORTED_MODULE_16__[\"NOT_LOADED\"];\n        } // return all Bs that don't have any A\n\n\n        var emptyIdArgs = lodash_filter__WEBPACK_IMPORTED_MODULE_1___default()(idArgs, function (idArg) {\n          return !lodash_size__WEBPACK_IMPORTED_MODULE_0___default()(getAIdsOfB(idArg));\n        });\n        return lodash_map__WEBPACK_IMPORTED_MODULE_4___default()(emptyIdArgs, function (idArg) {\n          return idArg[n.bId];\n        });\n      }), _readers)\n    };\n  }\n};\n/**\n * Some data access (especially delete calls) have \n * different implementation, depending on the relationship type.\n * \n * Any relationship will only add one of these.\n */\n\nvar specializedDataModelGenerators = {\n  /**\n   * Only one-to-many relationships have these data model nodes\n   */\n  oneToMany: function oneToMany(n, dataProvider, cfg) {\n    var _writers;\n\n    return {\n      children: {},\n      readers: {},\n      writers: (_writers = {}, _defineProperty(_writers, n.addAToB, function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(args, readers, injected, writers) {\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return batchUpdate(args, writers, dataProvider,\n                  /*#__PURE__*/\n                  function () {\n                    var _ref3 = _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee(args) {\n                      return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              return _context.abrupt(\"return\", _defineProperty({}, readers[n.aIdOfB].getPath(args), 1));\n\n                            case 1:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, this);\n                    }));\n\n                    return function (_x9) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }());\n\n                case 2:\n                  return _context2.abrupt(\"return\", _context2.sent);\n\n                case 3:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        return function (_x5, _x6, _x7, _x8) {\n          return _ref2.apply(this, arguments);\n        };\n      }()), _defineProperty(_writers, n.deleteAFromB, function () {\n        var _ref5 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee4(args, readers, injected, writers) {\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return batchUpdate(args, writers, dataProvider,\n                  /*#__PURE__*/\n                  function () {\n                    var _ref6 = _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee3(args) {\n                      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              return _context3.abrupt(\"return\", _defineProperty({}, readers[n.aIdOfB].getPath(args), null));\n\n                            case 1:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3, this);\n                    }));\n\n                    return function (_x14) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }());\n\n                case 2:\n                  return _context4.abrupt(\"return\", _context4.sent);\n\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        return function (_x10, _x11, _x12, _x13) {\n          return _ref5.apply(this, arguments);\n        };\n      }()), _defineProperty(_writers, n.deleteAllAsFromB, function () {\n        var _ref8 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee6(args, readers, injected, writers) {\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return batchUpdate(args, writers, dataProvider,\n                  /*#__PURE__*/\n                  function () {\n                    var _ref9 = _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee5(args) {\n                      return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                        while (1) {\n                          switch (_context5.prev = _context5.next) {\n                            case 0:\n                              throw new Error('NYI');\n\n                            case 1:\n                            case \"end\":\n                              return _context5.stop();\n                          }\n                        }\n                      }, _callee5, this);\n                    }));\n\n                    return function (_x19) {\n                      return _ref9.apply(this, arguments);\n                    };\n                  }());\n\n                case 2:\n                  return _context6.abrupt(\"return\", _context6.sent);\n\n                case 3:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        return function (_x15, _x16, _x17, _x18) {\n          return _ref8.apply(this, arguments);\n        };\n      }()), _defineProperty(_writers, n.deleteB, function () {\n        var _ref10 = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee8(args, readers, injected, writers) {\n          return regeneratorRuntime.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  _context8.next = 2;\n                  return batchUpdate(args, writers, dataProvider,\n                  /*#__PURE__*/\n                  function () {\n                    var _ref11 = _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee7(args) {\n                      var updates, aIds;\n                      return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                        while (1) {\n                          switch (_context7.prev = _context7.next) {\n                            case 0:\n                              updates = {};\n\n                              if (!cfg.aBelongsToB) {\n                                _context7.next = 9;\n                                break;\n                              }\n\n                              _context7.next = 4;\n                              return readers[n.aIdsOfB].readAsync(args);\n\n                            case 4:\n                              _context7.t0 = _context7.sent;\n\n                              if (_context7.t0) {\n                                _context7.next = 7;\n                                break;\n                              }\n\n                              _context7.t0 = _util__WEBPACK_IMPORTED_MODULE_15__[\"EmptyObject\"];\n\n                            case 7:\n                              aIds = _context7.t0;\n                              // delete all a's that belong to given b\n                              Object.assign(updates, lodash_zipObject__WEBPACK_IMPORTED_MODULE_9___default()(lodash_map__WEBPACK_IMPORTED_MODULE_4___default()(aIds, function (aId) {\n                                return readers[n.a].getPath(_objectSpread({}, args, _defineProperty({}, n.aId, aId)));\n                              }), lodash_times__WEBPACK_IMPORTED_MODULE_10___default()(aIds.length, function () {\n                                return null;\n                              })));\n\n                            case 9:\n                              // remove all a's from this b\n                              updates[readers[n.aIdsOfB].getPath(args)] = null; // finally, actually delete b\n\n                              updates[readers[n.b].getPath(args)] = null;\n                              return _context7.abrupt(\"return\", updates);\n\n                            case 12:\n                            case \"end\":\n                              return _context7.stop();\n                          }\n                        }\n                      }, _callee7, this);\n                    }));\n\n                    return function (_x24) {\n                      return _ref11.apply(this, arguments);\n                    };\n                  }());\n\n                case 2:\n                  return _context8.abrupt(\"return\", _context8.sent);\n\n                case 3:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8, this);\n        }));\n\n        return function (_x20, _x21, _x22, _x23) {\n          return _ref10.apply(this, arguments);\n        };\n      }()), _writers)\n    };\n  },\n\n  /**\n   * Only many-to-many relationships have these data model nodes.\n   * \n   * @param {*} n1 Names for b-hasMany-a relationship\n   * @param {*} n2 Names for a-hasMany-b relationship (effectively reversing meaning of a + b)\n   */\n  manyToMany: function manyToMany(n1, n2, dataProvider, cfg) {\n    var _writers2;\n\n    var genDeleteB = function genDeleteB(n1, n2) {\n      return (\n        /*#__PURE__*/\n        function () {\n          var _ref12 = _asyncToGenerator(\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee10(args, readers, injected, writers) {\n            var aIds;\n            return regeneratorRuntime.wrap(function _callee10$(_context10) {\n              while (1) {\n                switch (_context10.prev = _context10.next) {\n                  case 0:\n                    _context10.next = 2;\n                    return readers[n1.aIdsOfB].readAsync(args);\n\n                  case 2:\n                    _context10.t0 = _context10.sent;\n\n                    if (_context10.t0) {\n                      _context10.next = 5;\n                      break;\n                    }\n\n                    _context10.t0 = _util__WEBPACK_IMPORTED_MODULE_15__[\"EmptyObject\"];\n\n                  case 5:\n                    aIds = _context10.t0;\n                    _context10.next = 8;\n                    return batchUpdate(args, writers, dataProvider,\n                    /*#__PURE__*/\n                    function () {\n                      var _ref13 = _asyncToGenerator(\n                      /*#__PURE__*/\n                      regeneratorRuntime.mark(function _callee9(args) {\n                        var updates;\n                        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                          while (1) {\n                            switch (_context9.prev = _context9.next) {\n                              case 0:\n                                // remove b from all it's a's\n                                updates = lodash_zipObject__WEBPACK_IMPORTED_MODULE_9___default()(lodash_map__WEBPACK_IMPORTED_MODULE_4___default()(aIds, function (aId) {\n                                  return readers[n2.aIdOfB].getPath(_objectSpread({}, args, _defineProperty({}, n1.aId, aId)));\n                                }), lodash_times__WEBPACK_IMPORTED_MODULE_10___default()(aIds.length, function () {\n                                  return null;\n                                })); // remove all a's from this b\n\n                                updates[readers[n1.aIdsOfB].getPath(args)] = null; // finally, actually delete b\n\n                                updates[readers[n1.b].getPath(args)] = null;\n\n                              case 3:\n                              case \"end\":\n                                return _context9.stop();\n                            }\n                          }\n                        }, _callee9, this);\n                      }));\n\n                      return function (_x29) {\n                        return _ref13.apply(this, arguments);\n                      };\n                    }());\n\n                  case 8:\n                    return _context10.abrupt(\"return\", _context10.sent);\n\n                  case 9:\n                  case \"end\":\n                    return _context10.stop();\n                }\n              }\n            }, _callee10, this);\n          }));\n\n          return function (_x25, _x26, _x27, _x28) {\n            return _ref12.apply(this, arguments);\n          };\n        }()\n      );\n    };\n\n    var connectAB =\n    /*#__PURE__*/\n    function () {\n      var _ref14 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee12(args, readers, injected, writers) {\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return batchUpdate(args, writers, dataProvider,\n                /*#__PURE__*/\n                function () {\n                  var _ref15 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee11(args) {\n                    var _ref16;\n\n                    return regeneratorRuntime.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            return _context11.abrupt(\"return\", (_ref16 = {}, _defineProperty(_ref16, readers[n1.aIdOfB].getPath(args), 1), _defineProperty(_ref16, readers[n2.aIdOfB].getPath(args), 1), _ref16));\n\n                          case 1:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11, this);\n                  }));\n\n                  return function (_x34) {\n                    return _ref15.apply(this, arguments);\n                  };\n                }());\n\n              case 2:\n                return _context12.abrupt(\"return\", _context12.sent);\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      return function connectAB(_x30, _x31, _x32, _x33) {\n        return _ref14.apply(this, arguments);\n      };\n    }();\n\n    var disconnectAB =\n    /*#__PURE__*/\n    function () {\n      var _ref17 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee14(args, readers, injected, writers) {\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return batchUpdate(args, writers, dataProvider,\n                /*#__PURE__*/\n                function () {\n                  var _ref18 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  regeneratorRuntime.mark(function _callee13(args) {\n                    var _ref19;\n\n                    return regeneratorRuntime.wrap(function _callee13$(_context13) {\n                      while (1) {\n                        switch (_context13.prev = _context13.next) {\n                          case 0:\n                            return _context13.abrupt(\"return\", (_ref19 = {}, _defineProperty(_ref19, readers[n1.aIdOfB].getPath(args), null), _defineProperty(_ref19, readers[n2.aIdOfB].getPath(args), null), _ref19));\n\n                          case 1:\n                          case \"end\":\n                            return _context13.stop();\n                        }\n                      }\n                    }, _callee13, this);\n                  }));\n\n                  return function (_x39) {\n                    return _ref18.apply(this, arguments);\n                  };\n                }());\n\n              case 2:\n                return _context14.abrupt(\"return\", _context14.sent);\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      return function disconnectAB(_x35, _x36, _x37, _x38) {\n        return _ref17.apply(this, arguments);\n      };\n    }();\n\n    return {\n      children: {},\n      readers: {},\n      writers: (_writers2 = {}, _defineProperty(_writers2, n1.connectAB, connectAB), _defineProperty(_writers2, n2.connectAB, connectAB), _defineProperty(_writers2, n1.disconnectAB, disconnectAB), _defineProperty(_writers2, n2.disconnectAB, disconnectAB), _defineProperty(_writers2, n1.deleteB, genDeleteB(n1, n2)), _defineProperty(_writers2, n1.deleteA, genDeleteB(n2, n1)), _writers2)\n    };\n  }\n};\n/**\n * ####################################################################################\n * Parse hasMany configuration\n * ####################################################################################\n */\n\nfunction _sanitizeHasManyConfigEntry(hasMany) {\n  if (lodash_isString__WEBPACK_IMPORTED_MODULE_6___default()(hasMany)) {\n    return {\n      name: hasMany\n    };\n  }\n\n  if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_7___default()(hasMany)) {\n    if (!hasMany.name) {\n      throw new Error(\"invalid hasMany configuration entry does not have a name - \".concat(JSON.stringify(hasMany)));\n    }\n\n    return hasMany;\n  }\n\n  throw new Error(\"invalid hasMany configuration entry must be string or plain object - \".concat(JSON.stringify(hasMany)));\n}\n\nfunction parseHasManyConfig(hasMany) {\n  if (lodash_isString__WEBPACK_IMPORTED_MODULE_6___default()(hasMany) || lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_7___default()(hasMany)) {\n    // one single entry\n    var entry = _sanitizeHasManyConfigEntry(hasMany);\n\n    return _defineProperty({}, entry.name, entry);\n  }\n\n  if (lodash_isArray__WEBPACK_IMPORTED_MODULE_8___default()(hasMany)) {\n    // a bunch of entries\n    var entries = lodash_map__WEBPACK_IMPORTED_MODULE_4___default()(hasMany, _sanitizeHasManyConfigEntry);\n    return lodash_zipObject__WEBPACK_IMPORTED_MODULE_9___default()(lodash_map__WEBPACK_IMPORTED_MODULE_4___default()(entries, 'name'), entries);\n  }\n\n  throw new Error(\"invalid hasMany configuration must be a single string or plain object, or an array thereof - \".concat(JSON.stringify(hasMany)));\n}\n/**\n * ####################################################################################\n * Graph: Relationships\n * ####################################################################################\n */\n\n/**\n * Relationships represent uni-directional and bi-directional edges in the Graph.\n */\n\n\nvar Relationship =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @type GraphNode\n   */\n\n  /**\n   * @type GraphNode\n   */\n\n  /**\n   * Settings for this relationship.\n   * E.g.: \"aBelongsToB\"\n   * \n   * @type Object\n   */\n  function Relationship(a, b, cfg) {\n    _classCallCheck(this, Relationship);\n\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"cfg\", void 0);\n\n    this.a = a;\n    this.b = b;\n    this.cfg = cfg;\n    this.dataProvider = this.a.treeNode.cfg.dataProviderName;\n\n    if (this.dataProvider !== this.b.treeNode.cfg.dataProviderName) {\n      throw new Error(\"Tried to build relationship between nodes of different DataProviders. Not supported yet - \".concat(this.a.name, \" (\").concat(this.a.treeNode.cfg.dataProviderName, \") and \").concat(this.b.name, \" (\").concat(this.b.treeNode.cfg.dataProviderName, \")\"));\n    }\n  }\n\n  _createClass(Relationship, [{\n    key: \"buildConfigEntry\",\n    value: function buildConfigEntry() {\n      // all relationship implement a function to build their config entry\n      throw new Error('[INTERNAL ERROR] Relationship did not override buildConfigEntry()');\n    }\n  }, {\n    key: \"relationshipName\",\n    get: function get() {\n      return getRelationshipName(this.a.name, this.b.name);\n    }\n  }]);\n\n  return Relationship;\n}();\n/**\n * Base-line \"hasMany\" relationship, could be one-to-many or\n * part of a many-to-many.\n */\n\n\nvar BHasManyARelationship =\n/*#__PURE__*/\nfunction (_Relationship) {\n  _inherits(BHasManyARelationship, _Relationship);\n\n  function BHasManyARelationship(a, b, cfg) {\n    _classCallCheck(this, BHasManyARelationship);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BHasManyARelationship).call(this, a, b, cfg)); //b.hasMany.push(this);\n  }\n\n  _createClass(BHasManyARelationship, [{\n    key: \"buildConfigEntry\",\n    value: function buildConfigEntry() {\n      var n = this.getNameProxy();\n      var dataProvider = this.dataProvider;\n      return _objectSpread({\n        dataProvider: dataProvider\n      }, basicDataModelGenerators.hasMany(n, dataProvider, this.cfg));\n    }\n  }, {\n    key: \"getNameProxy\",\n    value: function getNameProxy() {\n      var a = this.a,\n          b = this.b;\n      var aName = a.name;\n      var bName = b.name;\n      var aIdName = a.idName;\n      var bIdName = b.idName;\n      var bListName = b.listName;\n      return _getNameProxy(aName, bName, aIdName, bIdName, bListName);\n    }\n  }]);\n\n  return BHasManyARelationship;\n}(Relationship); // class ABelongsToBRelationship extends Relationship {\n//   constructor(parentCfgNode, a, b) {\n//     super(parentCfgNode, a, b);\n//     a.belongsTo.push(this);\n//   }\n// }\n\n/**\n * Unidirectional relationship: simply encapsulates a single hasMany relationship.\n * Has specialized data model that is different from m2m relationship.\n */\n\n\nvar OneToManyRelationship =\n/*#__PURE__*/\nfunction (_Relationship2) {\n  _inherits(OneToManyRelationship, _Relationship2);\n\n  function OneToManyRelationship(hasMany) {\n    var _this;\n\n    _classCallCheck(this, OneToManyRelationship);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OneToManyRelationship).call(this, hasMany.a, hasMany.b, hasMany.cfg));\n    _this.hasMany = hasMany;\n    return _this;\n  }\n\n  _createClass(OneToManyRelationship, [{\n    key: \"buildConfigEntry\",\n    value: function buildConfigEntry() {\n      var n = this.hasMany.getNameProxy();\n      return lodash_merge__WEBPACK_IMPORTED_MODULE_12___default()({}, this.hasMany.buildConfigEntry(), specializedDataModelGenerators.oneToMany(n, this.cfg));\n    }\n  }]);\n\n  return OneToManyRelationship;\n}(Relationship);\n/**\n * Bidirectional relationship: Built from two hasMany relationships.\n */\n\n\nvar ManyToManyRelationship =\n/*#__PURE__*/\nfunction (_Relationship3) {\n  _inherits(ManyToManyRelationship, _Relationship3);\n\n  function ManyToManyRelationship(bHasManyA, aHasManyB) {\n    var _this2;\n\n    _classCallCheck(this, ManyToManyRelationship);\n\n    //super(bHasManyA, aHasManyB);\n    var a = bHasManyA.a,\n        b = bHasManyA.b;\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ManyToManyRelationship).call(this, a, b));\n    _this2.bHasManyA = bHasManyA;\n    _this2.aHasManyB = aHasManyB;\n    return _this2;\n  }\n\n  _createClass(ManyToManyRelationship, [{\n    key: \"buildConfigEntry\",\n    value: function buildConfigEntry() {\n      var n1 = this.bHasManyA.getNameProxy();\n      var n2 = this.aHasManyB.getNameProxy();\n      return lodash_merge__WEBPACK_IMPORTED_MODULE_12___default()({}, this.bHasManyA.buildConfigEntry(), this.aHasManyB.buildConfigEntry(), specializedDataModelGenerators.manyToMany(n1, n2, this.dataProvider, this.cfg));\n    }\n  }]);\n\n  return ManyToManyRelationship;\n}(Relationship);\n/**\n * ####################################################################################\n * Graph: GraphNode\n * ####################################################################################\n */\n\n/**\n * GraphNodes wrap treeNodes,\n * specifically any treeNode with at least one of two types of relationships:\n * \n * 1) Either: has (owns) one or more other nodes (b of hasMany relationship)\n * 2) Or: belongs to one or more other nodes (a of hasMany relationship)\n * 3) Or: both (many-to-many)\n */\n\n\nvar GraphNode =\n/*#__PURE__*/\nfunction () {\n  // settings\n  function GraphNode(graph, treeNode) {\n    _classCallCheck(this, GraphNode);\n\n    _defineProperty(this, \"hasManyCfg\", void 0);\n\n    this.graph = graph;\n    this.treeNode = treeNode;\n    var configNode = treeNode.cfg;\n    var hasMany = configNode.hasMany; // parse hasMany config\n\n    this.hasManyCfg = hasMany && parseHasManyConfig(hasMany) || null;\n  }\n\n  _createClass(GraphNode, [{\n    key: \"doesHaveMany\",\n    value: function doesHaveMany(aName) {\n      return !!this.hasManyCfg && !!this.hasManyCfg[aName];\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.treeNode.name;\n    }\n  }, {\n    key: \"idName\",\n    get: function get() {\n      var configNode = this.treeNode.cfg;\n      var pathConfig = configNode.pathConfig;\n      var pathTemplate = pathConfig.pathTemplate;\n      return getIdNameFromPathTemplate(pathTemplate);\n    }\n  }, {\n    key: \"listName\",\n    get: function get() {\n      return this.treeNode.parent.name;\n    }\n  }]);\n\n  return GraphNode;\n}();\n\nvar DataRelationshipGraph =\n/*#__PURE__*/\nfunction () {\n  // array of basic relationships (BHasManyARelationship)\n  // Basic relationships by their owner (\"b\") graph node\n  // stored by name, since they are only inserted once, no matter if uni- or bi-directional\n\n  /**\n   * ####################################################################################\n   * Graph: basic construction\n   * ####################################################################################\n   */\n  function DataRelationshipGraph(tree) {\n    var _this3 = this;\n\n    _classCallCheck(this, DataRelationshipGraph);\n\n    _defineProperty(this, \"nodesByName\", {});\n\n    _defineProperty(this, \"basicRelationships\", []);\n\n    _defineProperty(this, \"basicRelationshipsByNode\", new Map());\n\n    _defineProperty(this, \"specializedRelationships\", {});\n\n    _defineProperty(this, \"getNode\", function (name) {\n      return _this3.nodesByName[name];\n    });\n\n    _defineProperty(this, \"_getOrCreateGraphNodeForTreeNode\", function (treeNode) {\n      var graphNode = _this3.getNode(treeNode.name);\n\n      if (!graphNode) {\n        // not added yet\n        graphNode = new GraphNode(_this3, treeNode);\n\n        _this3._addNode(graphNode);\n      }\n\n      return graphNode;\n    });\n\n    this.tree = tree;\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_14___default()(this);\n  }\n\n  _createClass(DataRelationshipGraph, [{\n    key: \"forEachNode\",\n    value: function forEachNode(fn) {\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default()(this.nodesByName, fn);\n    }\n  }, {\n    key: \"_buildGraph\",\n    value: function _buildGraph() {\n      var _this4 = this;\n\n      // build graph of all nodes that have explicit relationships with other nodes\n      this.tree.root.forEachNodeInSubTree(function (treeNode) {\n        var configNode = treeNode.cfg;\n        var hasMany = configNode.hasMany,\n            relationship = configNode.relationship;\n\n        if (hasMany || relationship) {\n          if (!treeNode.parent) {\n            throw new Error('Trying to (but not allowed to) add relationship to root node');\n          }\n\n          _this4._getOrCreateGraphNodeForTreeNode(treeNode);\n        }\n      }); //console.log(this.nodesByName);\n      // actually build the relationships\n\n      this._buildAllRelationships(); // // after all nodes have been added, directly fix up all related nodes\n      // this._completeEdges();\n\n    }\n    /**\n     * ####################################################################################\n     * Graph: build nodes\n     * ####################################################################################\n     */\n\n  }, {\n    key: \"_addNode\",\n    value: function _addNode(node) {\n      this.nodesByName[node.name] = node;\n    }\n    /**\n     * ####################################################################################\n     * Graph: build relationships\n     * ####################################################################################\n     */\n\n  }, {\n    key: \"_buildAllRelationships\",\n    value: function _buildAllRelationships() {\n      this.relationshipDataConfig = {\n        path: '_relationships',\n        children: {}\n      }; // build graph nodes + add basic relationships\n\n      this.forEachNode(this._addBasicRelationshipsForNode); // build specialized relationships (one-to-many and many-to-many)\n\n      this.buildSpecializedRelationships(); // generate config\n\n      this.buildRelationshipConfig();\n    }\n  }, {\n    key: \"_getConfigNode\",\n    value: function _getConfigNode(relationshipName) {\n      return this.relationshipDataConfig.children[relationshipName];\n    }\n    /**\n     * Gets (creates if necessary) empty node containing the data model for the relationship\n     */\n\n  }, {\n    key: \"_getOrCreateConfigNodeForRelationship\",\n    value: function _getOrCreateConfigNodeForRelationship(rel) {\n      var relationshipName = rel.relationshipName;\n      console.assert(relationshipName, 'relationshipName not defined in Relationship');\n\n      var node = this._getConfigNode(relationshipName);\n\n      if (!node) {\n        node = this.relationshipDataConfig.children[relationshipName] = {};\n      }\n\n      return node;\n    }\n  }, {\n    key: \"_addBasicRelationshipsForNode\",\n    value: function _addBasicRelationshipsForNode(bGraphNode) {\n      var _this5 = this;\n\n      var bTreeNode = bGraphNode.treeNode;\n      var bName = bGraphNode.name;\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default()(bGraphNode.hasManyCfg, function (hasManyCfg, aName) {\n        var aTreeNode = _this5.tree.root.getReadDescendantByName(aName);\n\n        if (!aTreeNode) {\n          throw new Error(\"invalid \\\"hasMany\\\" relationship in \".concat(bName, \": \").concat(aName, \" does not exist in data (sub-)tree\"));\n        }\n\n        if (!aTreeNode.isWriter || !aTreeNode.isReader) {\n          console.error(aTreeNode);\n          throw new Error(\"invalid \\\"hasMany\\\" relationship in \".concat(bName, \": \").concat(aName, \" must be (but is not) readable and writable\"));\n        }\n\n        var aGraphNode = _this5._getOrCreateGraphNodeForTreeNode(aTreeNode); // add hasMany relationship\n\n\n        _this5.addHasManyRelation(aGraphNode, bGraphNode, hasManyCfg);\n      }); // TODO: belongsTo relationships\n    }\n    /**\n     * Add simple HasMany relationship\n     */\n\n  }, {\n    key: \"addHasManyRelation\",\n    value: function addHasManyRelation(a, b, hasManyCfg) {\n      //console.log('addHasManyRelation', a, b, hasManyCfg);\n      var rel = new BHasManyARelationship(a, b, hasManyCfg);\n      this.basicRelationships.push(rel);\n      this.basicRelationshipsByNode.set(b, rel); //this._addRelationship(new ABelongsToBRelationship(cfgNode, a, b));\n    }\n    /**\n     * Build all specialized relationships (one-to-many and many-to-many)\n     */\n\n  }, {\n    key: \"buildSpecializedRelationships\",\n    value: function buildSpecializedRelationships() {\n      var _this6 = this;\n\n      this.basicRelationships.forEach(function (bHasManyA) {\n        var newRel;\n        var relName = bHasManyA.relationshipName;\n        console.assert(relName);\n\n        var aHasManyB = _this6.basicRelationshipsByNode.get(bHasManyA.a);\n\n        if (!aHasManyB) {\n          // only goes in one direction\n          newRel = new OneToManyRelationship(bHasManyA);\n        } else if (!_this6.specializedRelationships[relName]) {\n          // found first node of an m2m relationship\n          newRel = new ManyToManyRelationship(bHasManyA, aHasManyB);\n        } else {// nothing to do! (second node of an m2m relationship)\n        }\n\n        if (newRel) {\n          //console.log('add relationship:', relName);\n          _this6.specializedRelationships[relName] = newRel;\n        }\n      });\n    }\n  }, {\n    key: \"buildRelationshipConfig\",\n    value: function buildRelationshipConfig() {\n      var _this7 = this;\n\n      lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default()(this.specializedRelationships, function (rel) {\n        var cfgNode = _this7._getOrCreateConfigNodeForRelationship(rel);\n\n        cfgNode.path = rel.relationshipName;\n        lodash_merge__WEBPACK_IMPORTED_MODULE_12___default()(cfgNode, rel.buildConfigEntry());\n      });\n    } // _completeEdges() {\n    //   forEach(this.nodesByName, node => {\n    //     node.edges = map(node.edgeNames, this.getNode);\n    //   });\n    // }\n\n  }]);\n\n  return DataRelationshipGraph;\n}();\nfunction DataRelationshipPlugin(tree) {\n  var graph = new DataRelationshipGraph(tree);\n\n  graph._buildGraph(); // when finished building, add to tree!\n  //console.warn(graph.relationshipDataConfig);\n\n\n  tree.addChildToRoot('_relationships', graph.relationshipDataConfig);\n  return graph;\n}\n/**\n * ####################################################################################\n * Old examples\n * ####################################################################################\n */\n// examples of a-hasMany-b relationship:\n// a = project\n// b = user\n\nvar readers = {};\n\n//# sourceURL=webpack://dbdi/./plugins/DataRelationshipGraph.js?");

/***/ }),

/***/ 0:
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi ./DataAccessTracker.js ./dataAccessUtil.js ./DataDescriptorNode.js ./dataProviders/DataProviderBase.js ./dataProviders/MemoryDataProvider.js ./DataReadDescriptor.js ./DataSourceNode.js ./DataSourceTree.js ./DataStructureConfig.js ./DataWriteDescriptor.js ./index.js ./indices.js ./PathDescriptor.js ./PathUtil.js ./plugins/DataRelationshipGraph.js ./ProxyUtil.js ./util/auto-bind.js ./util/index.js ./util/pathUtil.js ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! /Users/domi/code/dbdi/src/DataAccessTracker.js */\"./DataAccessTracker.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/dataAccessUtil.js */\"./dataAccessUtil.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/DataDescriptorNode.js */\"./DataDescriptorNode.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/dataProviders/DataProviderBase.js */\"./dataProviders/DataProviderBase.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/dataProviders/MemoryDataProvider.js */\"./dataProviders/MemoryDataProvider.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/DataReadDescriptor.js */\"./DataReadDescriptor.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/DataSourceNode.js */\"./DataSourceNode.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/DataSourceTree.js */\"./DataSourceTree.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/DataStructureConfig.js */\"./DataStructureConfig.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/DataWriteDescriptor.js */\"./DataWriteDescriptor.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/index.js */\"./index.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/indices.js */\"./indices.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/PathDescriptor.js */\"./PathDescriptor.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/PathUtil.js */\"./PathUtil.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/plugins/DataRelationshipGraph.js */\"./plugins/DataRelationshipGraph.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/ProxyUtil.js */\"./ProxyUtil.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/util/auto-bind.js */\"./util/auto-bind.js\");\n__webpack_require__(/*! /Users/domi/code/dbdi/src/util/index.js */\"./util/index.js\");\nmodule.exports = __webpack_require__(/*! /Users/domi/code/dbdi/src/util/pathUtil.js */\"./util/pathUtil.js\");\n\n\n//# sourceURL=webpack://dbdi/multi_./DataAccessTracker.js_./dataAccessUtil.js_./DataDescriptorNode.js_./dataProviders/DataProviderBase.js_./dataProviders/MemoryDataProvider.js_./DataReadDescriptor.js_./DataSourceNode.js_./DataSourceTree.js_./DataStructureConfig.js_./DataWriteDescriptor.js_./index.js_./indices.js_./PathDescriptor.js_./PathUtil.js_./plugins/DataRelationshipGraph.js_./ProxyUtil.js_./util/auto-bind.js_./util/index.js_./util/pathUtil.js?");

/***/ })

/******/ });
});