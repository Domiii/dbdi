(window["webpackJsonpdbdi"] = window["webpackJsonpdbdi"] || []).push([["common"],{

/***/ "./DataAccessTracker.js":
/*!******************************!*\
  !*** ./DataAccessTracker.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataAccessTracker; });\n/* harmony import */ var _DataWriteDescriptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataWriteDescriptor */ \"./DataWriteDescriptor.js\");\n/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isObject */ \"../node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _util_auto_bind__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var _util_auto_bind__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_util_auto_bind__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ \"./util/index.js\");\n/* harmony import */ var _ProxyUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ProxyUtil */ \"./ProxyUtil.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\nvar DataAccessTracker =\n/*#__PURE__*/\nfunction () {\n  function DataAccessTracker(dataSourceTree, listener, _name) {\n    var _this = this;\n\n    _classCallCheck(this, DataAccessTracker);\n\n    _defineProperty(this, \"_dataSourceTree\", void 0);\n\n    _defineProperty(this, \"_listener\", void 0);\n\n    _defineProperty(this, \"_dataProviders\", new Set());\n\n    _defineProperty(this, \"_injectProxy\", void 0);\n\n    _defineProperty(this, \"_readerProxy\", void 0);\n\n    _defineProperty(this, \"_writerProxy\", void 0);\n\n    _defineProperty(this, \"_wrappedReaders\", {});\n\n    _defineProperty(this, \"_wrappedWriters\", {});\n\n    _defineProperty(this, \"s\", void 0);\n\n    _defineProperty(this, \"_resolveArgumentHandler\", {\n      get: function get(target, name) {\n        if (name in _ProxyUtil__WEBPACK_IMPORTED_MODULE_6__[\"sharedArgumentProxyProperties\"]) {\n          return _ProxyUtil__WEBPACK_IMPORTED_MODULE_6__[\"sharedArgumentProxyProperties\"][name](target);\n        }\n\n        if (!(name in target)) {\n          console.warn(\"Requested argument was not supplied for \".concat(_this._name, \":\"), name);\n        }\n\n        return target[name];\n      },\n      has: function has(target, name) {\n        if (name in _ProxyUtil__WEBPACK_IMPORTED_MODULE_6__[\"sharedArgumentProxyProperties\"]) {\n          return true;\n        }\n\n        return target.hasOwnProperty(name);\n      },\n      enumerate: function enumerate(target) {\n        return Object.keys(target);\n      },\n      ownKeys: function ownKeys(target) {\n        return Object.keys(target);\n      }\n    });\n\n    console.assert(!listener || lodash_isFunction__WEBPACK_IMPORTED_MODULE_3___default()(listener), 'listener must be function');\n    this._dataSourceTree = dataSourceTree;\n    this._listener = listener;\n    this._name = _name || '<unnamed DataAccessTracker>';\n    _util_auto_bind__WEBPACK_IMPORTED_MODULE_4___default()(this);\n\n    this._buildProxies();\n  }\n\n  _createClass(DataAccessTracker, [{\n    key: \"_buildProxies\",\n    // ################################################\n    // Private methods + properties\n    // ################################################\n    value: function _buildProxies() {\n      this._injectProxy = new Proxy({}, this._buildDataInjectProxyHandler());\n      this._readerProxy = new Proxy({}, this._buildReaderProxyHandler());\n      this._writerProxy = new Proxy({}, this._buildWriterProxyHandler());\n    }\n  }, {\n    key: \"_buildDataInjectProxyHandler\",\n    value: function _buildDataInjectProxyHandler() {\n      var _this2 = this;\n\n      return _defineProperty({\n        get: function get(target, name) {\n          if (name === 'toJSON') {\n            return null;\n          } // if (name in specialProxyProperties) {\n          //   return specialProxyProperties[name](target);\n          // }\n          // resolve node and return read data\n\n\n          var readData = _this2.resolveReadDataForce(name);\n\n          return readData();\n        },\n        has: function has(target, name) {\n          // if (name in specialProxyProperties) {\n          //   return true;\n          // }\n          var fn = _this2.resolveReadData(name);\n\n          return !!fn;\n        },\n        enumerate: function enumerate() {\n          return _this2._dataSourceTree.getAllReaderNames(); //throw new Error('[NYI] cannot enumerate \"Inject\" proxy (yet)');\n        },\n        ownKeys: function ownKeys() {\n          return _this2._dataSourceTree.getAllReaderNames(); //throw new Error('[NYI] cannot enumerate \"Inject\" proxy (yet)');\n        }\n      }, Symbol.iterator, function (target) {\n        return _this2._dataSourceTree.getAllReaderNames();\n      });\n    }\n  }, {\n    key: \"_buildReaderProxyHandler\",\n    value: function _buildReaderProxyHandler() {\n      var _this3 = this;\n\n      return _defineProperty({\n        get: function get(target, name) {\n          if (name === 'toJSON') {\n            return null;\n          } // if (name in specialProxyProperties) {\n          //   return specialProxyProperties[name](target);\n          // }\n          // resolve node and return call function to caller.\n          // let caller decide when to make the actual call and which arguments to supply.\n\n\n          return _this3.resolveReadDataForce(name);\n        },\n        has: function has(target, name) {\n          // if (name in specialProxyProperties) {\n          //   return true;\n          // }\n          var fn = _this3.resolveReadData(name);\n\n          return !!fn;\n        },\n        enumerate: function enumerate() {\n          return _this3._dataSourceTree.getAllReaderNames(); //throw new Error('[NYI] cannot enumerate \"Reader\" proxy (yet)');\n        },\n        ownKeys: function ownKeys() {\n          return _this3._dataSourceTree.getAllReaderNames(); //throw new Error('[NYI] cannot enumerate \"Reader\" proxy (yet)');\n        }\n      }, Symbol.iterator, function (target) {\n        return _this3._dataSourceTree.getAllReaderNames();\n      });\n    }\n  }, {\n    key: \"_buildWriterProxyHandler\",\n    value: function _buildWriterProxyHandler() {\n      var _this4 = this;\n\n      return _defineProperty({\n        get: function get(target, name) {\n          // if (name in specialProxyProperties) {\n          //   return specialProxyProperties[name](target);\n          // }\n          // resolve node and return call function to caller.\n          // let caller decide when to make the actual call and which arguments to supply.\n          return _this4.resolveWriteDataForce(name);\n        },\n        has: function has(target, name) {\n          // if (name in specialProxyProperties) {\n          //   return true;\n          // }\n          var fn = _this4.resolveWriteData(name);\n\n          return !!fn;\n        },\n        enumerate: function enumerate() {\n          return _this4._dataSourceTree.getAllWriterNames(); //throw new Error('[NYI] cannot enumerate \"Writer\" proxy (yet)');\n        },\n        ownKeys: function ownKeys() {\n          return _this4._dataSourceTree.getAllWriterNames(); //throw new Error('[NYI] cannot enumerate \"Writer\" proxy (yet)');\n        }\n      }, Symbol.iterator, function (target) {\n        return _this4._dataSourceTree.getAllWriterNames();\n      });\n    }\n  }, {\n    key: \"_wrapArgs\",\n    value: function _wrapArgs(args, node) {\n      if (args && args.____isWrapperProxy) {\n        // already wrapped\n        return args;\n      }\n\n      if (args !== undefined && args !== null && !lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2___default()(args)) {\n        var moreInfo = '';\n\n        if (lodash_isObject__WEBPACK_IMPORTED_MODULE_1___default()(args)) {\n          if (args.constructor) {\n            moreInfo = \"object of type \\\"\".concat(args.constructor.name, \"\\\"\");\n\n            try {\n              moreInfo += \" - \".concat(JSON.stringify(args));\n            } catch (err) {\n              //moreInfo += ` (could not stringify object - ${err.message})`;\n              var keys = Object.keys(args);\n              moreInfo += \" - with \".concat(keys.length, \" keys: \").concat(keys);\n            }\n          } else {\n            moreInfo = \"<object of unknown type>\\n \\u2192 keys: \".concat(Object.keys(args));\n          }\n        } else {\n          moreInfo = args;\n        }\n\n        throw new Error(\"Invalid arguments for data node \\\"\".concat(node.fullName, \"\\\"\\n\") + \"\\u2192 expected plain object but found: \".concat(moreInfo, \" \\u2190\\n\") + '(Did you pass a data accessor as event (use \"asEventHandler\" instead!)?)');\n      }\n\n      args = args || _util__WEBPACK_IMPORTED_MODULE_5__[\"EmptyObject\"];\n      return new Proxy(args, this._resolveArgumentHandler);\n    }\n  }, {\n    key: \"_wrapReadData\",\n    value: function _wrapReadData(node) {\n      var _this5 = this;\n\n      var wrappedReadData = function wrappedReadData(args) {\n        return node.readData(_this5._wrapArgs(args, node), _this5._readerProxy, _this5._injectProxy, _this5._writerProxy, _this5);\n      };\n\n      wrappedReadData.isLoaded = function (args) {\n        return node.isDataLoaded(_this5._wrapArgs(args, node), _this5._readerProxy, _this5._injectProxy, _this5._writerProxy, _this5);\n      };\n\n      wrappedReadData.readAsync = function (args) {\n        return node.readAsync(_this5._wrapArgs(args, node), _this5._readerProxy, _this5._injectProxy, _this5._writerProxy, _this5);\n      };\n\n      wrappedReadData.areAllLoaded = function (idArgs, args) {\n        return node.areAllLoaded(idArgs, _this5._wrapArgs(args, node), _this5._readerProxy, _this5._injectProxy, _this5._writerProxy, _this5);\n      };\n\n      return this._decorateWrapper(wrappedReadData, node);\n    }\n  }, {\n    key: \"_wrapWriteData\",\n    value: function _wrapWriteData(node) {\n      var _this6 = this;\n\n      var writeDescriptor = node.writeDescriptor; // get parameter config for action\n\n      var paramConfig = _DataWriteDescriptor__WEBPACK_IMPORTED_MODULE_0__[\"writeParameterConfig\"][writeDescriptor.actionName];\n      console.assert(paramConfig, 'writeParameterConfig in _wrapWriteData not defined for action ' + writeDescriptor.actionName);\n      var processArguments = paramConfig.processArguments;\n\n      var wrappedWriteData = function wrappedWriteData() {\n        for (var _len = arguments.length, writeArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n          writeArgs[_key] = arguments[_key];\n        }\n\n        // figure out the arguments for this action and wrap them\n        var allArgs = processArguments(node, writeArgs);\n        allArgs.queryArgs = _this6._wrapArgs(allArgs.queryArgs, node);\n\n        if (allArgs.val && allArgs.val.____isWrapperProxy) {\n          //throw new Error();\n          allArgs.val = allArgs.val.____proxyGetUnderlyingTarget;\n        }\n\n        return node.writeData(allArgs, _this6._readerProxy, _this6._injectProxy, _this6._writerProxy, _this6);\n      };\n\n      return this._decorateWrapper(wrappedWriteData, node);\n    }\n    /**\n     * Decorate any access wrapper, be it read or write.\n     */\n\n  }, {\n    key: \"_decorateWrapper\",\n    value: function _decorateWrapper(wrapper, node) {\n      var _this7 = this;\n\n      var pathDescriptor = node.pathDescriptor;\n\n      if (!pathDescriptor) {\n        wrapper.getPath = function () {\n          return undefined;\n        };\n      } else {\n        wrapper.getPath = function (args) {\n          return pathDescriptor.getPath(args, _this7._readerProxy, _this7._injectProxy, _this7);\n        };\n\n        wrapper.notifyPathChanged = function (args) {\n          var path = pathDescriptor.getPath(args, _this7._readerProxy, _this7._injectProxy, _this7);\n\n          if (path) {\n            node.dataProvider.markPossibleUpdate(path);\n          }\n        };\n      }\n\n      return wrapper;\n    }\n    /**\n     * Internally used by DataReadDescriptor to make sure that\n     * we will track the given path once it has been read once, until unmount is called.\n     */\n\n  }, {\n    key: \"_recordDataAccess\",\n    value: function _recordDataAccess(dataProvider, path) {\n      if (!this._listener) {\n        // we need this because registerListener adds the cached query in the DataProvider\n        this._listener = function () {};\n      }\n\n      dataProvider.registerListener(path, this._listener, this._name);\n\n      this._dataProviders.add(dataProvider);\n    } // ################################################\n    // Resolution\n    // ################################################\n\n  }, {\n    key: \"resolveReadData\",\n    value: function resolveReadData(name) {\n      if (!this._dataSourceTree.hasReader(name)) {\n        return undefined;\n      }\n\n      var readData = this._wrappedReaders[name];\n\n      if (!readData) {\n        var node = this._dataSourceTree.resolveReader(name);\n\n        this._wrappedReaders[name] = readData = this._wrapReadData(node);\n      }\n\n      return readData;\n    }\n    /**\n     * Throws error when reader of name does not exist\n     */\n\n  }, {\n    key: \"resolveReadDataForce\",\n    value: function resolveReadDataForce(name) {\n      var readData = this.resolveReadData(name);\n\n      if (!readData) {\n        debugger;\n        throw new Error(\"DI failed - reader does not exist: \\\"\".concat(name, \"\\\": \").concat(Object.keys(this._dataSourceTree._root._readDescendants).join(', ')));\n      }\n\n      return readData;\n    }\n  }, {\n    key: \"resolveWriteData\",\n    value: function resolveWriteData(name) {\n      if (!this._dataSourceTree.hasWriter(name)) {\n        return undefined;\n      }\n\n      var writeData = this._wrappedWriters[name];\n\n      if (!writeData) {\n        var node = this._dataSourceTree.resolveWriter(name);\n\n        this._wrappedWriters[name] = writeData = this._wrapWriteData(node);\n      }\n\n      return writeData;\n    }\n  }, {\n    key: \"resolveWriteDataForce\",\n    value: function resolveWriteDataForce(name) {\n      var writeData = this.resolveWriteData(name);\n\n      if (!writeData) {\n        throw new Error(\"DI failed - writer does not exist: \\\"\".concat(name, \"\\\": \").concat(Object.keys(this._dataSourceTree._root._writeDescendants).join(', ')));\n      }\n\n      return writeData;\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      var _this8 = this;\n\n      if (this._listener) {\n        // unregister listener from all data providers\n        this._dataProviders.forEach(function (dataProvider) {\n          dataProvider.unregisterListener(_this8._listener);\n        });\n\n        this._dataProviders = new Set();\n      }\n    } // ################################################\n    // Direct reads + writes\n    // ################################################\n\n  }, {\n    key: \"read\",\n    get: function get() {\n      return this._readerProxy;\n    }\n  }, {\n    key: \"write\",\n    get: function get() {\n      return this._writerProxy;\n    }\n    /**\n     * A lot of \"writers\" are actually more like \"actions\", \n     * so \"do\" is a more appropriate verb.\n     */\n\n  }, {\n    key: \"do\",\n    get: function get() {\n      return this._writerProxy;\n    }\n  }, {\n    key: \"get\",\n    get: function get() {\n      return this._injectProxy;\n    }\n  }]);\n\n  return DataAccessTracker;\n}();\n\n\n\n//# sourceURL=webpack://dbdi/./DataAccessTracker.js?");

/***/ }),

/***/ "./DataDescriptorNode.js":
/*!*******************************!*\
  !*** ./DataDescriptorNode.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataDescriptorNode; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Each DataDescriptorNode provides a methods to: 1) get a path, 2) read data or 3) write data\n */\nvar DataDescriptorNode =\n/*#__PURE__*/\nfunction () {\n  //_knownDependencies;\n  function DataDescriptorNode(cfg, name) {\n    _classCallCheck(this, DataDescriptorNode);\n\n    _defineProperty(this, \"_cfg\", void 0);\n\n    _defineProperty(this, \"_name\", void 0);\n\n    this._cfg = cfg;\n    this._name = name;\n  }\n\n  _createClass(DataDescriptorNode, [{\n    key: \"forEachNodeDFS\",\n    value: function forEachNodeDFS(fn) {} // TODO\n\n    /**\n     * DescriptorNode execute functions have four (five) sets of arguments:\n     * \n     * @param {object} args Set of user-supplied arguments.\n     * @param {object} namedCallProxy Set of all path/read calls executed right away, directly injecting the path/data to callee with no user arguments provided.\n     * @param {object} namedCalls Set of all path/read calls provided to the callee. Callee decides when to make the call and with what arguments.\n     * @param {object} callerNode The callerNode supplies access to the DataSource, and all kinds of advanced stuff. Use with caution.\n     * @param {object} writers set of required writer nodes. For writer nodes only! (Only writers can require more writers)\n     * \n     * They are called from the DataSourceNodeBindings which supplies the data the node requests.\n     * \n     * When nodes are called upon the first time, all data read sights are\n     * automatically added as dependencies and their loading initialized.\n     * \n     * When a call is made:\n     * 1) All injected data is automatically added to data dependencies immediately.\n     * 2) descriptor arguments are NOT added immediately, only after they are called.\n     * \n     * @returns {(string|Array.)} Returns one or more sets of data or paths\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(args, readerProxy, injectProxy, callerNode, accessTracker) {\n      throw new Error('DescriptorNode did not implement execute: ' + this.constructor.name);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[\".concat(this.constructor.name, \"] \").concat(this.name);\n    }\n  }, {\n    key: \"getDependencies\",\n    value: function getDependencies() {\n      return this._knownDependencies;\n    }\n    /**\n     * Protected method, called by descriptor nodes to indicate previously known dependencies.\n     * \n     * @param {*} dependencies \n     */\n\n  }, {\n    key: \"_setDependencies\",\n    value: function _setDependencies(dependencies) {\n      this._knownDependencies = dependencies;\n    }\n  }, {\n    key: \"_wrapAccessFunction\",\n    value: function _wrapAccessFunction(fn) {\n      return function _wrappedAccessFunction() {\n        try {\n          return fn.apply(void 0, arguments);\n        } catch (err) {\n          throw new Error(\"Failed to execute \\\"\".concat(this.nodeType, \"\\\" at node \\\"\").concat(this.name, \"\\\":\\n\") + (err && err.stack || err));\n        }\n      };\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._name;\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return this._cfg;\n    }\n  }, {\n    key: \"nodeType\",\n    get: function get() {\n      throw new Error('[INTERNAL ERROR] nodeType has not been defined in DataDescriptorNode class');\n    }\n  }]);\n\n  return DataDescriptorNode;\n}();\n\n\n\n//# sourceURL=webpack://dbdi/./DataDescriptorNode.js?");

/***/ }),

/***/ "./DataWriteDescriptor.js":
/*!********************************!*\
  !*** ./DataWriteDescriptor.js ***!
  \********************************/
/*! exports provided: writeParameterConfig, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"writeParameterConfig\", function() { return writeParameterConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataWriteDescriptor; });\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isArray */ \"../node_modules/lodash/isArray.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEmpty */ \"../node_modules/lodash/isEmpty.js\");\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var src_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/util */ \"./util/index.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _DataDescriptorNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DataDescriptorNode */ \"./DataDescriptorNode.js\");\n/* harmony import */ var _PathDescriptor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PathDescriptor */ \"./PathDescriptor.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\nvar DEBUG_WRITES = true;\n/**\n * Writer functions (except for delete) by default accept one or two arguments.\n * If only one argument is given, it is the value to be written.\n * If two arguments are given, the first argument is the queryArgs object passed to the PathDescriptor, and the second argument is the value to be written.\n * \n * @param {*} node \n * @param {*} writeArgs \n */\n\nfunction processArgumentsDefault(node, writeArgs) {\n  var res;\n  var queryArgs, val;\n\n  switch (writeArgs.length) {\n    // case 0:\n    //   res = EmptyObject;\n    //   break;\n    case 1:\n      var _writeArgs = _slicedToArray(writeArgs, 1);\n\n      val = _writeArgs[0];\n      res = {\n        val: val\n      };\n      break;\n\n    case 2:\n      var _writeArgs2 = _slicedToArray(writeArgs, 2);\n\n      queryArgs = _writeArgs2[0];\n      val = _writeArgs2[1];\n      res = {\n        queryArgs: queryArgs,\n        val: val\n      };\n      break;\n\n    default:\n      throw new Error(\"Invalid argument count provided for write operation at \".concat(node.fullName, \" (must be 1 or 2): \\n          \").concat(JSON.stringify(writeArgs)));\n  }\n\n  return res;\n}\n/**\n * Assume only the first argument to be valid,\n * but if first argument is not given, take second.\n * Will only have queryArgs (which will be wrapped with proxy by DataAccessTracker).\n */\n\n\nfunction processCustomSetter(node, writeArgs) {\n  if (writeArgs.length > 1) {\n    console.error('custom writer should only provide one argument but found two @', node.name, 'â†’', writeArgs);\n  } // let [queryArgs, val] = writeArgs;\n  // if (!isEmpty(queryArgs) && !isEmpty(val)) {\n  //    problem!\n  // }\n  // if (!queryArgs) {\n  //   queryArgs = val;\n  // }\n\n\n  return {\n    queryArgs: writeArgs[0]\n  };\n}\n\nfunction processArgumentsNoValue(node, writeArgs) {\n  // only query arguments, no value\n  var _writeArgs3 = _slicedToArray(writeArgs, 1),\n      queryArgs = _writeArgs3[0];\n\n  return {\n    queryArgs: queryArgs\n  };\n}\n\nfunction processArgumentsUndetermined(node, writeArgs) {\n  return {\n    varArgs: writeArgs\n  };\n}\n\nvar writeParameterConfig = Object.freeze({\n  push: {\n    parameterCount: 2,\n    processArguments: processArgumentsDefault\n  },\n  set: {\n    parameterCount: 2,\n    processArguments: processArgumentsDefault\n  },\n  update: {\n    parameterCount: 2,\n    processArguments: processArgumentsDefault\n  },\n  delete: {\n    parameterCount: 1,\n    processArguments: processArgumentsNoValue\n  },\n  custom: {\n    parameterCount: 1,\n    //processArguments: processArgumentsUndetermined\n    processArguments: processCustomSetter\n  }\n});\n\nvar DataWriteDescriptor =\n/*#__PURE__*/\nfunction (_DataDescriptorNode) {\n  _inherits(DataWriteDescriptor, _DataDescriptorNode);\n\n  function DataWriteDescriptor(writerCfg, writeMetaCfg, name) {\n    var _this;\n\n    _classCallCheck(this, DataWriteDescriptor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DataWriteDescriptor).call(this, writerCfg, name));\n\n    _defineProperty(_assertThisInitialized(_this), \"actionName\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"onWrite\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"pathDescriptor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"writeData\", void 0);\n\n    _this.actionName = writeMetaCfg.actionName;\n    _this.onWrite = writeMetaCfg.onWrite;\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5___default()(_assertThisInitialized(_this));\n\n    _this._buildWriteData(writerCfg);\n\n    return _this;\n  }\n\n  _createClass(DataWriteDescriptor, [{\n    key: \"_buildWriteData\",\n    // ################################################\n    // Private properties + methods\n    // ################################################\n    value: function _buildWriteData(writerCfg) {\n      var writeData;\n\n      if (writerCfg instanceof _PathDescriptor__WEBPACK_IMPORTED_MODULE_7__[\"default\"]) {\n        // build writer from pathDescriptor\n        writeData = this._buildWriterFromDescriptor(writerCfg);\n      } else if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_0___default()(writerCfg)) {\n        // custom writer function\n        writeData = this._buildCustomWriter(writerCfg);\n      } else {\n        throw new Error(\"Could not make sense of writer config node '\".concat(this.name, \"' - Must either be path (string) or function:\\n\").concat(JSON.stringify(writerCfg, null, 2)));\n      }\n\n      this.writeData = this._wrapAccessFunction(writeData);\n    }\n  }, {\n    key: \"_doGetPath\",\n    value: function _doGetPath(pathDescriptor, args, readerProxy, injectProxy, callerNode, accessTracker) {\n      var pathOrPaths = pathDescriptor.getPath(args, readerProxy, injectProxy, callerNode, accessTracker);\n\n      if (pathOrPaths !== undefined) {\n        if (lodash_isString__WEBPACK_IMPORTED_MODULE_3___default()(pathOrPaths)) {\n          var path = pathOrPaths;\n          return path;\n        } else {\n          //if (isArray(pathOrPaths)) {\n          throw new Error('[NYI] pathOrPaths must be (but is not) string. PathDescriptor broken?');\n        }\n      }\n\n      throw new Error('Tried to write to path but not all arguments were provided: ' + this._name + ' - ' + ' - ' + JSON.stringify(args) + ' vs. ' + JSON.stringify(pathDescriptor.config));\n    }\n    /**\n     * This is used only in nodes that (1) don't have a path and (2) provided an explicit `writer` function.\n     * NOTE: Method signature of custom writers are slightly different, in that they don't separate `queryArgs` and `val`\n     * (but rather any written value is contained in the `queryArgs`).\n     */\n\n  }, {\n    key: \"_buildCustomWriter\",\n    value: function _buildCustomWriter(writerFn) {\n      var _this2 = this;\n\n      return function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n        // // TODO check if all dependencies are loaded?\n        // if (!callerNode.areDependenciesLoaded(this)) {\n        //   return null;\n        // }\n        var queryArgs = args.queryArgs; // WARNING: custom writer has a different onWrite signature from the path-based writer\n\n        _this2.onWrite && _this2.onWrite(queryArgs, _this2.actionName, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n        return writerFn(queryArgs, readerProxy, injectProxy, writerProxy, callerNode, accessTracker); // this.onWrite && this.onWrite(...varArgs, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n        // return writerFn(...varArgs, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n      };\n    }\n  }, {\n    key: \"_buildWriterFromDescriptor\",\n    value: function _buildWriterFromDescriptor(pathDescriptor) {\n      var _this3 = this;\n\n      this.pathDescriptor = pathDescriptor;\n      return function (args, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n        // // TODO check if all dependencies are loaded?\n        // if (!callerNode.areDependenciesLoaded(this)) {\n        //   return null;\n        // }\n        var queryArgs = args.queryArgs,\n            val = args.val;\n\n        var path = _this3._doGetPath(pathDescriptor, queryArgs, readerProxy, injectProxy, callerNode, accessTracker);\n\n        return _this3._writeToPath(path, val, queryArgs, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n      };\n    }\n    /**\n     * This is called when writing to a node built from a PathDescriptor.\n     */\n\n  }, {\n    key: \"_writeToPath\",\n    value: function _writeToPath(queryInput, val, queryArgs, readerProxy, injectProxy, writerProxy, callerNode, accessTracker) {\n      var dataProvider = callerNode.dataProvider; //accessTracker.recordDataWrite(dataProvider, path, val);\n      // update indices first\n\n      if (this.pathDescriptor && this.pathDescriptor.indices) {\n        this.pathDescriptor.indices.updateIndices(val);\n      } // custom write hooks\n      // TODO: Call on child nodes as well\n\n\n      if (this.onWrite) {\n        var originalVal = dataProvider.readData(queryInput);\n        this.onWrite(queryArgs, val, originalVal, this.actionName, readerProxy, injectProxy, writerProxy, callerNode, accessTracker);\n      } // perform write action\n      //console.warn(this.actionName, queryInput);\n\n\n      return dataProvider.actions[this.actionName](queryInput, val);\n    }\n  }, {\n    key: \"nodeType\",\n    get: function get() {\n      return 'DataWrite';\n    }\n  }]);\n\n  return DataWriteDescriptor;\n}(_DataDescriptorNode__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n\n\n//# sourceURL=webpack://dbdi/./DataWriteDescriptor.js?");

/***/ }),

/***/ "./PathDescriptor.js":
/*!***************************!*\
  !*** ./PathDescriptor.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PathDescriptor; });\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isArray */ \"../node_modules/lodash/isArray.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var src_util_pathUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/util/pathUtil */ \"./util/pathUtil.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/util/auto-bind */ \"./util/auto-bind.js\");\n/* harmony import */ var src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _PathUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathUtil */ \"./PathUtil.js\");\n/* harmony import */ var _indices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./indices */ \"./indices.js\");\n/* harmony import */ var _DataDescriptorNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DataDescriptorNode */ \"./DataDescriptorNode.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\nvar defaultIndexSettings = {\n  forceSimpleEncoding: true\n};\n\nvar PathDescriptor =\n/*#__PURE__*/\nfunction (_DataDescriptorNode) {\n  _inherits(PathDescriptor, _DataDescriptorNode);\n\n  function PathDescriptor(parent, pathConfig, name) {\n    var _this;\n\n    _classCallCheck(this, PathDescriptor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PathDescriptor).call(this, pathConfig, name));\n\n    _defineProperty(_assertThisInitialized(_this), \"getPath\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"parent\", void 0);\n\n    _this.parent = parent;\n    src_util_auto_bind__WEBPACK_IMPORTED_MODULE_5___default()(_assertThisInitialized(_this));\n\n    _this._buildPathGetter(pathConfig);\n\n    return _this;\n  } // ################################################\n  // Public properties + methods\n  // ################################################\n\n\n  _createClass(PathDescriptor, [{\n    key: \"getParentPathDescriptor\",\n    value: function getParentPathDescriptor() {\n      return this.parent;\n    }\n  }, {\n    key: \"updatePath\",\n    value: function updatePath() {\n      this.setPath(this.config.localPathTemplate);\n    }\n  }, {\n    key: \"getLocalPath\",\n    value: function getLocalPath() {\n      return this.config.localPathTemplate;\n    }\n  }, {\n    key: \"setPath\",\n    value: function setPath(path) {\n      this.config.localPathTemplate = path;\n      this.config.pathTemplate = Object(src_util_pathUtil__WEBPACK_IMPORTED_MODULE_4__[\"pathJoin\"])(this.parent.config.pathTemplate, path);\n\n      this._buildPathGetter();\n    } // ################################################\n    // Private methods\n    // ################################################\n\n  }, {\n    key: \"_buildPathGetter\",\n    value: function _buildPathGetter() {\n      var pathConfig = this.config;\n      var getPath;\n      var pathTemplate = pathConfig.pathTemplate,\n          queryParams = pathConfig.queryParams,\n          pathFn = pathConfig.pathFn,\n          indices = pathConfig.indices;\n      this.indices = indices && Object(_indices__WEBPACK_IMPORTED_MODULE_7__[\"makeIndices\"])(indices, defaultIndexSettings);\n\n      if (!pathFn) {\n        getPath = this._buildGetPathFromTemplateString(pathTemplate, queryParams);\n      } else {\n        getPath = pathFn;\n      } // finally, wrap path getter call\n\n\n      this.getPath = this._wrapGetPath(getPath);\n    }\n  }, {\n    key: \"_wrapGetPath\",\n    value: function _wrapGetPath(getPath) {\n      return function _wrappedGetPath(args, readerProxy, injectProxy, callerNode, accessTracker) {\n        var path;\n\n        try {\n          path = getPath(args, readerProxy, injectProxy, callerNode, accessTracker);\n        } catch (err) {\n          console.error('Failed to execute getPath at: ' + this + ' - ' + err.stack);\n        } // if (path !== undefined && !isArray(path)) { //&& !isString(path)) {\n        //   // TODO: (low prio) Proper type checking (e.g.: https://github.com/gkz/type-check)\n        //   throw new Error('getPath did not return string or array-of-string at: ' + this);\n        // }\n\n\n        return path;\n      };\n    }\n  }, {\n    key: \"_transformQueryParams\",\n    value: function _transformQueryParams(queryParamsRaw) {\n      if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_3___default()(queryParamsRaw)) {\n        if (this.indices) {\n          return this.indices.where(queryParamsRaw);\n        }\n      }\n\n      return queryParamsRaw;\n    }\n  }, {\n    key: \"_buildGetPathFromTemplateString\",\n    value: function _buildGetPathFromTemplateString(pathTemplate, _queryParamsInput) {\n      var _this2 = this;\n\n      var indices = this.indices;\n      var variableTransform = indices && indices.encodeQueryValueForProps.bind(indices);\n      var getPathRaw = Object(_PathUtil__WEBPACK_IMPORTED_MODULE_6__[\"createPathGetterFromTemplateProps\"])(pathTemplate, variableTransform); //const argNames = getPathRaw.pathInfo && getPathRaw.pathInfo.varNames;\n\n      if (!_queryParamsInput) {\n        // no custom query parameters\n        return function (args, readerProxy, injectProxy, callerNode, _accessTracker) {\n          return _this2._getPath(args, getPathRaw);\n        };\n      } else {\n        // handle custom query parameters\n        return function (args, readerProxy, injectProxy, callerNode, accessTracker) {\n          // get queryParams\n          var queryParamsRaw = lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(_queryParamsInput) ? _queryParamsInput(args, readerProxy, injectProxy, callerNode, accessTracker) : _queryParamsInput; // apply transform\n\n          var queryParams = _this2._transformQueryParams(queryParamsRaw);\n\n          if (queryParams) {\n            return {\n              path: getPathRaw(args),\n              queryParams: queryParams\n            };\n          } else {\n            return _this2._getPath(args, getPathRaw);\n          }\n        };\n      }\n    }\n  }, {\n    key: \"_getPath\",\n    value: function _getPath(args, getPathRaw) {\n      var path = getPathRaw(args); // if (this.indices) {\n      //   console.warn(path, args, args.sessionId);\n      // }\n\n      if (this.indices && this.indices.doesQueryMatchAnyPropertyIndex(args)) {\n        // match an index -> add index query\n        // console.log({\n        //   path: getPathRaw(args),\n        //   indx: this.indices.getIndexNameByKeys(args)\n        //   //queryParams: this.indices.where(args)\n        // });\n        return {\n          path: path,\n          queryParams: this.indices.where(args)\n        };\n      }\n\n      return path;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.config.pathTemplate;\n    }\n  }, {\n    key: \"nodeType\",\n    get: function get() {\n      return 'Path';\n    }\n  }]);\n\n  return PathDescriptor;\n}(_DataDescriptorNode__WEBPACK_IMPORTED_MODULE_8__[\"default\"]);\n\n\n\n//# sourceURL=webpack://dbdi/./PathDescriptor.js?");

/***/ }),

/***/ "./PathUtil.js":
/*!*********************!*\
  !*** ./PathUtil.js ***!
  \*********************/
/*! exports provided: _makePathVariable, createPathGetterFromTemplateProps, createPathGetterFromTemplateArray, createPathGetterFromTemplate, getVarRe, getFirstVariableInPathTemplate, parseTemplateString, createChildVarGetterFromTemplateProps, getDataIn, setDataIn, getPathParent, getAllNodesInPath, getAllAncestorNodesInPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_makePathVariable\", function() { return _makePathVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPathGetterFromTemplateProps\", function() { return createPathGetterFromTemplateProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPathGetterFromTemplateArray\", function() { return createPathGetterFromTemplateArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPathGetterFromTemplate\", function() { return createPathGetterFromTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVarRe\", function() { return getVarRe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFirstVariableInPathTemplate\", function() { return getFirstVariableInPathTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseTemplateString\", function() { return parseTemplateString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createChildVarGetterFromTemplateProps\", function() { return createChildVarGetterFromTemplateProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDataIn\", function() { return getDataIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDataIn\", function() { return setDataIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPathParent\", function() { return getPathParent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAllNodesInPath\", function() { return getAllNodesInPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAllAncestorNodesInPath\", function() { return getAllAncestorNodesInPath; });\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/get */ \"../node_modules/lodash/get.js\");\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/set */ \"../node_modules/lodash/set.js\");\n/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_some__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/some */ \"../node_modules/lodash/some.js\");\n/* harmony import */ var lodash_some__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_some__WEBPACK_IMPORTED_MODULE_3__);\nvar _marked =\n/*#__PURE__*/\nregeneratorRuntime.mark(getAllNodesInPath),\n    _marked2 =\n/*#__PURE__*/\nregeneratorRuntime.mark(getAllAncestorNodesInPath);\n\n\n\n\n\nfunction _makePathVariable(val, varName, variableTransform) {\n  if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_0___default()(val) && variableTransform) {\n    // use transformation for variable\n    return variableTransform(val, varName);\n  }\n\n  return val;\n} // creates a function that plugs in path variables \n//  from a single plain object argument that names variables explicitely\n\nfunction createPathGetterFromTemplateProps(pathTemplate, variableTransform) {\n  var varLookup = function varLookup(props, varName, iArg) {\n    if (variableTransform) {\n      return variableTransform(props, varName, iArg);\n    }\n\n    var prop = props && props[varName];\n\n    if (prop === undefined) {\n      throw new Error(\"invalid arguments: \".concat(varName, \" was not provided for path \").concat(pathTemplate));\n    } //return _makePathVariable(prop, varName, variableTransform);\n\n\n    return prop;\n  };\n\n  var getPathWithVariables = function getPathWithVariables(props) {\n    var nodeOutput = getPathWithVariables.pathInfo.nodes.map(function (node) {\n      return node(props);\n    });\n\n    if (lodash_some__WEBPACK_IMPORTED_MODULE_3___default()(nodeOutput, function (output) {\n      return output === undefined;\n    })) {\n      return undefined;\n    }\n\n    return nodeOutput.join('');\n  };\n\n  return createPathGetterFromTemplate(pathTemplate, varLookup, getPathWithVariables);\n} // creates a function that plugs in path variables from the function's arguments\n\nfunction createPathGetterFromTemplateArray(pathTemplate, variableTransform) {\n  var varLookup = function varLookup(args, varName, iArg) {\n    if (!args || iArg >= args.length) {\n      //debugger;\n      throw new Error(\"invalid arguments: \".concat(varName, \" was not provided for path \").concat(pathTemplate));\n    }\n\n    return _makePathVariable(args[iArg], varName, variableTransform);\n  };\n\n  var getPathWithVariables = function getPathWithVariables() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return getPathWithVariables.pathInfo.nodes.map(function (node) {\n      return node(args);\n    }).join('');\n  };\n\n  return createPathGetterFromTemplate(pathTemplate, varLookup, getPathWithVariables);\n}\nfunction createPathGetterFromTemplate(pathTemplate, varLookup, getPathWithVariables) {\n  var pathInfo = parseTemplateString(pathTemplate, varLookup);\n  var getPath;\n\n  if (pathInfo.nVars > 0) {\n    // template substitution from array\n    getPath = getPathWithVariables;\n    getPath.hasVariables = true;\n  } else {\n    // no variable substitution necessary\n    getPath = function getPath() {\n      return pathTemplate;\n    };\n\n    getPath.hasVariables = false;\n  }\n\n  getPath.pathInfo = pathInfo;\n  getPath.pathTemplate = pathTemplate;\n  return getPath;\n}\n/**\n * Since RegExp.exec is stateful in JS, we kinda really do NOT want to have different agents share the same re instance.\n * Creates a new instance every time instead.\n */\n\nvar getVarRe = function getVarRe() {\n  return /\\$\\(([^)]+)\\)/g;\n};\nfunction getFirstVariableInPathTemplate(pathTemplate) {\n  var varRe = getVarRe();\n  var match = varRe.exec(pathTemplate);\n\n  if (match) {\n    return match[1];\n  }\n\n  return null;\n} // see: http://codepen.io/Domiii/pen/zNOEaO?editors=0010\n\nfunction parseTemplateString(text, varLookup) {\n  text = text || '';\n  var nVars = 0,\n      nTexts = 0;\n\n  function textNode(text) {\n    ++nTexts;\n    return function (props) {\n      return text;\n    };\n  }\n\n  function varNode(varName) {\n    var iVar = nVars;\n    ++nVars;\n    return function (args) {\n      return varLookup(args, varName, iVar);\n    };\n  }\n\n  var nodes = [];\n  var varNames = [];\n  var lastIndex = 0;\n  var match;\n  var varRe = getVarRe();\n\n  while ((match = varRe.exec(text)) !== null) {\n    var matchStart = match.index,\n        matchEnd = varRe.lastIndex;\n\n    var _prevText = text.substring(lastIndex, matchStart);\n\n    var varName = match[1];\n    varNames.push(varName);\n\n    if (_prevText.length > 0) {\n      nodes.push(textNode(_prevText));\n    }\n\n    nodes.push(varNode(varName));\n    lastIndex = matchEnd;\n  }\n\n  var prevText = text.substring(lastIndex, text.length);\n\n  if (prevText.length > 0) {\n    nodes.push(textNode(prevText));\n  }\n\n  return {\n    nVars: nVars,\n    nTexts: nTexts,\n    varNames: varNames,\n    nodes: nodes\n  };\n}\nfunction createChildVarGetterFromTemplateProps(pathTemplate, varNames) {\n  return function (props) {\n    return varNames.map(function (varName) {\n      if (!props || props[varName] === undefined) {\n        //debugger;\n        throw new Error(\"invalid arguments: \".concat(varName, \" was not provided for path \").concat(pathTemplate));\n      }\n\n      return props[varName];\n    });\n  };\n} // convert to dot notation for lodash path access\n\nfunction _convertPathToObjNotation(path) {\n  path = path || '';\n  path = path.toString();\n  path = path.replace(/\\//g, '.');\n  path = path.replace(/\\.\\./g, '.');\n\n  if (path[0] === '.') {\n    path = path.substring(1);\n  }\n\n  return path;\n}\n\nfunction getDataIn(obj, path) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  path = _convertPathToObjNotation(path);\n\n  if (!path) {\n    // handle empty path separately\n    // see: https://github.com/lodash/lodash/issues/3386\n    if (obj === undefined) return defaultValue;\n    return obj;\n  }\n\n  return lodash_get__WEBPACK_IMPORTED_MODULE_1___default()(obj, path, defaultValue);\n}\nfunction setDataIn(obj, path, val) {\n  path = _convertPathToObjNotation(path);\n\n  if (!path) {\n    // handle empty path separately\n    // see: https://github.com/lodash/lodash/issues/3386\n    if (obj !== undefined) {\n      Object.assign(obj, val);\n    }\n  }\n\n  return lodash_set__WEBPACK_IMPORTED_MODULE_2___default()(obj, path, val);\n}\nfunction getPathParent(path) {\n  if (!path) return null;\n\n  while (path.endsWith('/')) {\n    path = path.substring(0, path.length - 1);\n  }\n\n  if (!path) return null;\n  var idx = path.lastIndexOf('/');\n\n  if (idx < 0) {\n    // root path\n    return '';\n  }\n\n  return path.substring(0, idx);\n}\nfunction getAllNodesInPath(path) {\n  return regeneratorRuntime.wrap(function getAllNodesInPath$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          while (path.startsWith('/')) {\n            path = path.substring(1);\n          }\n\n          _context.next = 3;\n          return path;\n\n        case 3:\n          if (!path) {\n            _context.next = 5;\n            break;\n          }\n\n          return _context.delegateYield(getAllAncestorNodesInPath(path), \"t0\", 5);\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this);\n}\nfunction getAllAncestorNodesInPath(path) {\n  return regeneratorRuntime.wrap(function getAllAncestorNodesInPath$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          while (path.startsWith('/')) {\n            path = path.substring(1);\n          }\n\n        case 1:\n          if (!(path = getPathParent(path))) {\n            _context2.next = 6;\n            break;\n          }\n\n          _context2.next = 4;\n          return path;\n\n        case 4:\n          _context2.next = 1;\n          break;\n\n        case 6:\n          _context2.next = 8;\n          return '';\n\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, this);\n}\n\n//# sourceURL=webpack://dbdi/./PathUtil.js?");

/***/ }),

/***/ "./ProxyUtil.js":
/*!**********************!*\
  !*** ./ProxyUtil.js ***!
  \**********************/
/*! exports provided: sharedArgumentProxyProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sharedArgumentProxyProperties\", function() { return sharedArgumentProxyProperties; });\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_0__);\n\nvar sharedArgumentProxyProperties = {\n  // need to hack this, because Proxies are transparently virtualized\n  // https://stackoverflow.com/questions/36372611/how-to-test-if-an-object-is-a-proxy\n  ____isWrapperProxy: function ____isWrapperProxy() {\n    return true;\n  },\n  ____proxyGetUnderlyingTarget: function ____proxyGetUnderlyingTarget(target) {\n    console.assert(!target || !target.____isWrapperProxy);\n    console.warn('____proxyGetUnderlyingTarget', target);\n    return target;\n  },\n  toJSON: function toJSON(target) {\n    if (lodash_isString__WEBPACK_IMPORTED_MODULE_0___default()(target)) {\n      return JSON.parse(target);\n    }\n\n    return target;\n  }\n};\n\n//# sourceURL=webpack://dbdi/./ProxyUtil.js?");

/***/ }),

/***/ "./dataAccessUtil.js":
/*!***************************!*\
  !*** ./dataAccessUtil.js ***!
  \***************************/
/*! exports provided: getOptionalArguments, getOptionalArgument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptionalArguments\", function() { return getOptionalArguments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptionalArgument\", function() { return getOptionalArgument; });\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/mapValues */ \"../node_modules/lodash/mapValues.js\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/map */ \"../node_modules/lodash/map.js\");\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction getOptionalArguments(args) {\n  for (var _len = arguments.length, namesOrConfig = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    namesOrConfig[_key - 1] = arguments[_key];\n  }\n\n  var argsConfig = namesOrConfig[0];\n\n  if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_2___default()(argsConfig)) {\n    return lodash_mapValues__WEBPACK_IMPORTED_MODULE_0___default()(argsConfig, function (defaultVal, name) {\n      if (name in args) {\n        return args[name];\n      }\n\n      return defaultVal;\n    });\n  }\n\n  var names = namesOrConfig;\n  return lodash_map__WEBPACK_IMPORTED_MODULE_1___default()(names, function (name) {\n    return getOptionalArgument(args, name);\n  });\n}\nfunction getOptionalArgument(args, name) {\n  var defaultVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return name in args && args[name] || defaultVal;\n}\n\n//# sourceURL=webpack://dbdi/./dataAccessUtil.js?");

/***/ }),

/***/ "./dataProviders/DataProviderBase.js":
/*!*******************************************!*\
  !*** ./dataProviders/DataProviderBase.js ***!
  \*******************************************/
/*! exports provided: NOT_LOADED, LoadState, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NOT_LOADED\", function() { return NOT_LOADED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadState\", function() { return LoadState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataProviderBase; });\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/forEach */ \"../node_modules/lodash/forEach.js\");\n/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEmpty */ \"../node_modules/lodash/isEmpty.js\");\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lodash_pull__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/pull */ \"../node_modules/lodash/pull.js\");\n/* harmony import */ var lodash_pull__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_pull__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var src_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/util */ \"./util/index.js\");\n/* harmony import */ var _PathUtil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../PathUtil */ \"./PathUtil.js\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\nvar NOT_LOADED = undefined;\nvar LoadState = {\n  NotLoaded: 0,\n  Fetching: 1,\n  Loaded: 2\n};\n/**\n * The amount of time to wait before deleting data + metadata \n * from cache after unloading (in ms)\n */\n\nvar purgeCacheDelayDefault = 60 * 1000; //const purgeCacheDelayDefault = 10;\n\nvar fetchFailDelay = 5 * 1000; // stop trying after a while\n\nvar fetchMaxFailCount = 10;\n\nvar DataProviderBase =\n/*#__PURE__*/\nfunction () {\n  function DataProviderBase() {\n    _classCallCheck(this, DataProviderBase);\n\n    _defineProperty(this, \"_listenersByPath\", {});\n\n    _defineProperty(this, \"_queriesByLocalPath\", new Map());\n\n    _defineProperty(this, \"_listenerData\", new Map());\n\n    _defineProperty(this, \"_loadState\", {});\n\n    _defineProperty(this, \"_fetchFails\", {});\n\n    _defineProperty(this, \"_cache\", {});\n\n    _defineProperty(this, \"actions\", {\n      set: function set(remotePath, val) {\n        throw new Error('DataProvider did not implement `set` action');\n      },\n      push: function push(remotePath, val) {\n        throw new Error('DataProvider did not implement `push` action');\n      },\n      update: function update(remotePath, val) {\n        throw new Error('DataProvider did not implement `update` action');\n      },\n      delete: function _delete(remotePath) {\n        throw new Error('DataProvider did not implement `delete` action');\n      } // transaction: () => {\n      // },\n      // batchUpdate: () => {\n      // }\n\n    });\n  }\n\n  _createClass(DataProviderBase, [{\n    key: \"getLoadState\",\n    // #################################################################################################\n    // Load state\n    // #################################################################################################\n    value: function getLoadState(localPath) {\n      return this._loadState[localPath] || LoadState.NotLoaded;\n    }\n  }, {\n    key: \"isDataLoaded\",\n    value: function isDataLoaded(localPath) {\n      return this._loadState[localPath] === LoadState.Loaded;\n    }\n    /**\n     * Generally speaking, if data is not fully loaded under a path,\n     * we don't return the incomplete version of that data, that is why we want\n     * to make sure that data is loaded at path (or any ancestory) before returning it.\n     */\n\n  }, {\n    key: \"isDataFullyAvailable\",\n    value: function isDataFullyAvailable(query) {\n      var localPath = query.localPath,\n          remotePath = query.remotePath;\n\n      if (this.isDataLoaded(localPath)) {\n        return true;\n      }\n\n      if (localPath === remotePath) {\n        for (var path in Object(_PathUtil__WEBPACK_IMPORTED_MODULE_7__[\"getAllNodesInPath\"])(remotePath)) {\n          if (this.isDataLoaded(path)) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        // cannot reliably/easily destructure (or make sense of) a path that contains advanced query data\n        return false;\n      }\n    }\n  }, {\n    key: \"setLoadState\",\n    value: function setLoadState(localPath, state) {\n      this._loadState[localPath] = state;\n    } // #################################################################################################\n    // Query & Path management\n    // #################################################################################################\n\n  }, {\n    key: \"getQueryByQueryInput\",\n    value: function getQueryByQueryInput(queryInput) {\n      var localPath = this.getLocalPath(queryInput);\n      return this.getQueryByLocalPath(localPath);\n    }\n  }, {\n    key: \"getQuery\",\n    value: function getQuery(queryInput) {\n      var localPath = this.getLocalPath(queryInput);\n      return this.getQueryByLocalPath(localPath);\n    }\n  }, {\n    key: \"getOrCreateQuery\",\n    value: function getOrCreateQuery(queryInput) {\n      var localPath = this.getLocalPath(queryInput);\n      return this._getOrCreateQuery(localPath, queryInput);\n    }\n  }, {\n    key: \"_getOrCreateQuery\",\n    value: function _getOrCreateQuery(localPath, queryInput) {\n      var q = this.getQueryByLocalPath(localPath);\n\n      if (!q) {\n        q = this._registerQuery(localPath, queryInput);\n      }\n\n      return q;\n    }\n  }, {\n    key: \"getQueryByLocalPath\",\n    value: function getQueryByLocalPath(localPath) {\n      return this._queriesByLocalPath.get(localPath);\n    }\n  }, {\n    key: \"getLocalPath\",\n    value: function getLocalPath(queryInput) {\n      var localPath;\n\n      if (lodash_isString__WEBPACK_IMPORTED_MODULE_3___default()(queryInput)) {\n        localPath = queryInput;\n      } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4___default()(queryInput)) {\n        // local path is any unique string representation of the queryInput\n        localPath = JSON.stringify(queryInput);\n      }\n\n      return localPath;\n    }\n  }, {\n    key: \"getRemotePath\",\n    value: function getRemotePath(queryInput) {\n      var remotePath;\n\n      if (lodash_isString__WEBPACK_IMPORTED_MODULE_3___default()(queryInput)) {\n        remotePath = queryInput;\n      } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_4___default()(queryInput)) {\n        // remote path is the path part of the query (which can include further arguments)\n        remotePath = queryInput.path;\n      }\n\n      return remotePath;\n    }\n  }, {\n    key: \"_setQueryCache\",\n    value: function _setQueryCache(query) {\n      var localPath = query.localPath;\n\n      this._queriesByLocalPath.set(localPath, query);\n    }\n  }, {\n    key: \"_buildQuery\",\n    value: function _buildQuery(localPath, queryInput) {\n      // does not exist yet\n      var remotePath = this.getRemotePath(queryInput);\n      return {\n        queryInput: queryInput,\n        localPath: localPath,\n        remotePath: remotePath,\n        _useCount: 0\n      };\n    }\n  }, {\n    key: \"_registerQuery\",\n    value: function _registerQuery(localPath, queryInput) {\n      var cachedQuery = this._buildQuery(localPath, queryInput);\n\n      this._setQueryCache(cachedQuery);\n\n      return cachedQuery;\n    }\n    /**\n     * Build + don't cache query\n     */\n\n  }, {\n    key: \"justGimmeAQuery\",\n    value: function justGimmeAQuery(queryInput) {\n      var localPath = this.getLocalPath(queryInput);\n      var cachedQuery = this.getQueryByLocalPath(localPath);\n\n      if (!cachedQuery) {\n        return this._buildQuery(localPath, queryInput);\n      } else {//++cachedQuery._useCount;\n      }\n\n      return cachedQuery;\n    } // #################################################################################################\n    // Listeners\n    // #################################################################################################\n\n  }, {\n    key: \"getListeners\",\n    value: function getListeners(localPath) {\n      return this._listenersByPath[localPath];\n    }\n  }, {\n    key: \"registerListener\",\n    value: function registerListener(queryInput, listener, who) {\n      console.assert(lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(listener), '[INTERNAL ERROR] listener must be function but found: ' + listener);\n      var localPath = this.getLocalPath(queryInput);\n      var listeners = this.getListeners(localPath);\n\n      if (!listeners) {\n        // first time, anyone is showing interest in this path\n        this._listenersByPath[localPath] = listeners = new Set(); // if not already listening on path, register!\n        //console.warn(who, '[onPathListenStart]', localPath);\n\n        var query = this._getOrCreateQuery(localPath, queryInput);\n\n        var customData = this.onPathListenStart(query, listener);\n        query.customData = customData;\n      }\n\n      if (listeners.has(listener) && !this._listenerData.get(listener)) {\n        console.error('something wrong with registerListener:', listeners.has(listener), !!this._listenerData.get(listener));\n      }\n\n      if (!listeners.has(listener)) {\n        // add listener to set (if not already listening)\n        listeners.add(listener);\n      }\n\n      var listenerData = this._listenerData.get(listener);\n\n      if (!listenerData) {\n        this._listenerData.set(listener, listenerData = {\n          byPath: {}\n        });\n      }\n\n      if (!listenerData.byPath[localPath]) {\n        this._listenerData.get(listener).byPath[localPath] = {//query,\n        };\n      }\n    }\n  }, {\n    key: \"unregisterListener\",\n    value: function unregisterListener(listener) {\n      var _this = this;\n\n      var listenerData = this._listenerData.get(listener);\n\n      if (!!listenerData) {\n        var byPath = listenerData.byPath; // we need to first copy the set of keys, since\n        //    we will delete keys from byPath, thereby making an iteration on byPath \n        //    itself cause all kinds of issues...\n\n        lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(byPath, function (pathData, localPath) {\n          return _this._unregisterListenerPath(localPath, pathData, listener);\n        });\n      }\n    }\n  }, {\n    key: \"_unregisterListenerPath\",\n    value: function _unregisterListenerPath(localPath, pathData, listener) {\n      var _this2 = this;\n\n      //console.log('unregister path: ' + localPath);\n      var listeners = this.getListeners(localPath);\n\n      var listenerData = this._listenerData.get(listener);\n\n      if (!listenerData) {\n        console.error('[INTERNAL ERROR] listener data not set at path: ' + localPath);\n        return;\n      }\n\n      if (!listeners || !listeners.has(listener)) {\n        console.error('[INTERNAL ERROR] listener not registered at path: ' + localPath);\n        return;\n      } // delete all kinds of stuff\n\n\n      delete listenerData.byPath[localPath];\n\n      if (lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(listenerData.byPath)) {\n        // we removed the last path for listener: delete listener, as well\n        //console.warn('listeners.delete');\n        listeners.delete(listener);\n\n        this._listenerData.delete(listener);\n      }\n\n      setTimeout(function () {\n        if (lodash_isEmpty__WEBPACK_IMPORTED_MODULE_1___default()(listeners)) {\n          // we removed the last listener at path\n          _this2._onPathUnused(localPath);\n        }\n      }, purgeCacheDelayDefault);\n    }\n  }, {\n    key: \"_onPathUnused\",\n    value: function _onPathUnused(localPath) {\n      var query = this.getQueryByLocalPath(localPath);\n\n      if (!query) {\n        // already removed\n        return;\n      } //console.log('UNLOAD', localPath);\n\n\n      delete this._listenersByPath[localPath];\n\n      this._queriesByLocalPath.delete(localPath);\n\n      delete this._loadState[localPath];\n\n      if (this._fetchFails[localPath]) {\n        delete this._fetchFails[localPath];\n      }\n\n      this.onPathListenEnd(query, query.customData);\n    } // #################################################################################################\n    // Handle data\n    // #################################################################################################\n\n  }, {\n    key: \"notifyNewData\",\n    value: function notifyNewData(query, val) {\n      var _ref = query || src_util__WEBPACK_IMPORTED_MODULE_6__[\"EmptyObject\"],\n          localPath = _ref.localPath;\n\n      if (val === NOT_LOADED) {\n        if (this.isDataLoaded(localPath)) {\n          this.setLoadState(localPath, LoadState.NotLoaded); //console.log('UNLOAD ', localPath, ' -> ', val);\n        }\n      } else if (!this.isDataLoaded(localPath)) {\n        this.setLoadState(localPath, LoadState.Loaded); //console.log('LOAD ', localPath, ' -> ', val);\n      } else {} //console.log('NEW DATA ', localPath, ' -> ', val);\n        // update cache\n        //const oldVal = getDataIn();\n\n\n      Object(_PathUtil__WEBPACK_IMPORTED_MODULE_7__[\"setDataIn\"])(this._cache, localPath, val);\n\n      this._notifyListeners(query); //);\n      // setTimeout(() => {\n      //   for (let i = listeners.length-1; i >= 0; --i) {\n      //   for (let i = 0; i < listeners.length; ++i) {\n      //     listeners[i](query, val);\n      //   }\n      // });\n\n    }\n  }, {\n    key: \"readData\",\n    value: function readData(queryInput) {\n      var query = this.getQueryByQueryInput(queryInput);\n\n      if (!query) {\n        return NOT_LOADED;\n      }\n\n      var localPath = query.localPath;\n      var val = Object(_PathUtil__WEBPACK_IMPORTED_MODULE_7__[\"getDataIn\"])(this._cache, localPath, NOT_LOADED);\n      console.log('READ [', queryInput, ']', this._loadState[query.localPath], val);\n\n      if (this.isDataFullyAvailable(query)) {\n        if (val !== NOT_LOADED) {\n          return val;\n        } else {\n          return null;\n        }\n      } else {\n        if (val !== NOT_LOADED && val !== null) {\n          // TODO: i forgot the use-case for this, but I'm sure it would break something if we removed it\n          console.warn('data vailable but not \"fully\" available:', queryInput, ' - ', val);\n          return val; //throw new Error('data vailable but not \"fully\" available - returning null: ' + queryInput + ' - ' + val);\n        }\n\n        return NOT_LOADED;\n      }\n    }\n  }, {\n    key: \"markPossibleUpdate\",\n    value: function markPossibleUpdate(queryInput) {\n      var query = this.getQueryByQueryInput(queryInput);\n\n      if (query) {\n        this._notifyListeners(query);\n      }\n    }\n  }, {\n    key: \"_notifyListeners\",\n    value: function _notifyListeners(query) {\n      var localPath = query.localPath; // notify all listeners\n\n      var listeners = this.getListeners(localPath);\n      console.assert(!listeners || listeners instanceof Set, '[BUG] listeners is not a set at path = ' + localPath);\n      listeners = listeners || src_util__WEBPACK_IMPORTED_MODULE_6__[\"EmptyArray\"]; // listeners will get called once per path\n      //setTimeout(() => \n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var l = _step.value;\n          l(query);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // #################################################################################################\n    // Fetching (async readers)\n    // #################################################################################################\n\n    /**\n     * Determines whether the current state allows for/needs a fetch\n     */\n\n  }, {\n    key: \"fetchStart\",\n    value: function fetchStart(queryInput) {\n      var query = this.getQueryByQueryInput(queryInput); //console.warn('R [', queryInput, '] ', query, this._loadState[query.localPath]);\n\n      if (!query) {\n        return false;\n      }\n\n      var localPath = query.localPath;\n\n      if (this.getLoadState(localPath) !== LoadState.NotLoaded) {\n        return false;\n      }\n\n      var fetchFailCount = this._fetchFails[localPath];\n\n      if (fetchFailCount >= fetchMaxFailCount) {\n        // past the fail limit\n        console.error(\"exceeded fetch fail limit @\".concat(localPath, \" - stopped trying.\"));\n        return false;\n      } // set load state to fetching\n      //  (which is technically still \"NotLoaded\", but we set state to \"Fetching\", to prevent double fetching)\n\n\n      this.setLoadState(localPath, LoadState.Fetching); // if failed before, delay!\n\n      if (fetchFailCount > 0) {\n        console.warn(\"previous fetch failed @\".concat(localPath, \" - throttling\"));\n        return Object(src_util__WEBPACK_IMPORTED_MODULE_6__[\"waitAsync\"])(fetchFailDelay).then(function () {\n          return true;\n        });\n      }\n\n      return true;\n    }\n    /**\n     * Update state based on fetched result\n     */\n\n  }, {\n    key: \"fetchEnd\",\n    value: function fetchEnd(queryInput, val) {\n      var query = this.getQueryByQueryInput(queryInput);\n      if (!query) return;\n      var localPath = query.localPath,\n          remotePath = query.remotePath;\n\n      if (val === NOT_LOADED) {\n        this.fetchFailed(queryInput, 'fetch returned NOT_LOADED');\n      } else {\n        if (this.getLoadState(localPath) !== LoadState.Fetching) {\n          // something happened in the meantime -> discard fetched result\n          console.warn('discarding fetched result because path status changed @', localPath, '-', val);\n          return;\n        } // reset failure\n\n\n        this._fetchFails[localPath] = null; // update state\n\n        this.setLoadState(localPath, LoadState.Loaded); // set new state + notify all listeners\n\n        this.actions.set(remotePath, val);\n      }\n    }\n  }, {\n    key: \"fetchFailed\",\n    value: function fetchFailed(queryInput, err) {\n      console.error(\"Failed to fetch path \\\"\".concat(queryInput, \"\\\" - \"), err && err.stack || err);\n      var query = this.getQueryByQueryInput(queryInput);\n      if (!query) return;\n      var localPath = query.localPath,\n          remotePath = query.remotePath;\n\n      if (this.getLoadState(localPath) !== LoadState.Fetching) {\n        // something happened in the meantime -> discard fetched result\n        return;\n      } // remember failure\n\n\n      this._fetchFails[localPath] = (this._fetchFails[localPath] || 0) + 1; // downgrade load state at path\n\n      this.setLoadState(localPath, LoadState.NotLoaded);\n      this.actions.set(remotePath, NOT_LOADED);\n    } // #################################################################################################\n    // Any DataProvider can implement the following methods\n    // #################################################################################################\n\n    /**\n     * Fetch data once, asynchronously, no strings attached.\n     */\n\n  }, {\n    key: \"fetchOnce\",\n    value: function () {\n      var _fetchOnce = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", NOT_LOADED);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetchOnce() {\n        return _fetchOnce.apply(this, arguments);\n      }\n\n      return fetchOnce;\n    }()\n    /**\n     * A listener started listening on a path for the first time\n     * -> That signals DataProviders to start fetching their data.\n     */\n\n  }, {\n    key: \"onPathListenStart\",\n    value: function onPathListenStart(query, firstListener) {} //throw new Error('DataProvider did not implement `onListenerAdd` method');\n\n    /**\n     * Not a single soul cares about the localPath in the given query anymore\n     */\n\n  }, {\n    key: \"onPathListenEnd\",\n    value: function onPathListenEnd(query, customData) {//throw new Error('DataProvider did not implement `onListenerRemove` method');\n    }\n  }]);\n\n  return DataProviderBase;\n}();\n\n\n\n//# sourceURL=webpack://dbdi/./dataProviders/DataProviderBase.js?");

/***/ }),

/***/ "./indices.js":
/*!********************!*\
  !*** ./indices.js ***!
  \********************/
/*! exports provided: makeIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeIndices\", function() { return makeIndices; });\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isArray */ \"../node_modules/lodash/isArray.js\");\n/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isPlainObject */ \"../node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isString */ \"../node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_isString__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isString__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_isArrayLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isArrayLike */ \"../node_modules/lodash/isArrayLike.js\");\n/* harmony import */ var lodash_isArrayLike__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isArrayLike__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isFunction */ \"../node_modules/lodash/isFunction.js\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lodash_isElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isElement */ \"../node_modules/lodash/isElement.js\");\n/* harmony import */ var lodash_isElement__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isElement__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var lodash_isError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isError */ \"../node_modules/lodash/isError.js\");\n/* harmony import */ var lodash_isError__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_isError__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isNumber */ \"../node_modules/lodash/isNumber.js\");\n/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var lodash_isBoolean__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/isBoolean */ \"../node_modules/lodash/isBoolean.js\");\n/* harmony import */ var lodash_isBoolean__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash_isBoolean__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var lodash_isDate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isDate */ \"../node_modules/lodash/isDate.js\");\n/* harmony import */ var lodash_isDate__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash_isDate__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/sortBy */ \"../node_modules/lodash/sortBy.js\");\n/* harmony import */ var lodash_sortBy__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash_sortBy__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var lodash_zipObject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/zipObject */ \"../node_modules/lodash/zipObject.js\");\n/* harmony import */ var lodash_zipObject__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(lodash_zipObject__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/map */ \"../node_modules/lodash/map.js\");\n/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash/mapValues */ \"../node_modules/lodash/mapValues.js\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var lodash_findKey__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash/findKey */ \"../node_modules/lodash/findKey.js\");\n/* harmony import */ var lodash_findKey__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(lodash_findKey__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lodash/keys */ \"../node_modules/lodash/keys.js\");\n/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(lodash_keys__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var lodash_some__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lodash/some */ \"../node_modules/lodash/some.js\");\n/* harmony import */ var lodash_some__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(lodash_some__WEBPACK_IMPORTED_MODULE_16__);\n/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash/has */ \"../node_modules/lodash/has.js\");\n/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(lodash_has__WEBPACK_IMPORTED_MODULE_17__);\n/* harmony import */ var lodash_flatten__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lodash/flatten */ \"../node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_flatten__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(lodash_flatten__WEBPACK_IMPORTED_MODULE_18__);\n/* harmony import */ var lodash_join__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lodash/join */ \"../node_modules/lodash/join.js\");\n/* harmony import */ var lodash_join__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(lodash_join__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var lodash_every__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash/every */ \"../node_modules/lodash/every.js\");\n/* harmony import */ var lodash_every__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(lodash_every__WEBPACK_IMPORTED_MODULE_20__);\n/* harmony import */ var lodash_includes__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! lodash/includes */ \"../node_modules/lodash/includes.js\");\n/* harmony import */ var lodash_includes__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(lodash_includes__WEBPACK_IMPORTED_MODULE_21__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Determine whether two arrays contain exactly the same elements, independent of order.\n * @see https://stackoverflow.com/questions/32103252/expect-arrays-to-be-equal-ignoring-order/48973444#48973444\n */\n\nfunction cmpIgnoreOrder(a, b) {\n  return a.length === b.length && lodash_every__WEBPACK_IMPORTED_MODULE_20___default()(a, function (v) {\n    return lodash_includes__WEBPACK_IMPORTED_MODULE_21___default()(b, v);\n  });\n}\n\nvar globalDefaultConfig = {\n  keys: [],\n\n  /**\n   * Whether the index should be handled as property, and added as property to object on write.\n   * Set this to false for indices representing parent path keys/ids.\n   * \n   * Relation to `updateOnWrite`: \n   * If `isProperty` is set to `false`, \n   *    the index will never be written.\n   * If `isProperty` is `true` and `updateOnWrite` is `false`, \n   *    it will at least be written initially.\n   * \n   * Default: true.\n   */\n  isProperty: true,\n\n  /**\n   * Whether to update the index on every \n   * write operation (given it's keys are present).\n   * If this is set to false, it will only try \n   * to write the index when it has not previously \n   * been written.\n   * \n   * Default: false.\n   * Reason: Often indices are set on properties that never change.\n   */\n  updateOnWrite: false,\n  // Whether to show a warning when an index cannot \n  // be updated due to missing key data.\n  // You only want to set this to true when you are sure \n  // that all required keys are set at \n  // every possible index update (at every write).\n  isRequired: true,\n\n  /**\n   * Whether the encoded values should be simplified.\n   * This makes them simpler but also might risk chances of ambiguity\n   * (different values encoded to the same result).\n   * You want to turn this off, if you have keys that contain non-constrained sets of characters,\n   *    and/or have other risks for keys to mash up into each other, \n   *    and thus risk non-uniqueness between different inputs.\n   */\n  forceSimpleEncoding: true\n};\nfunction makeIndices(cfg, defaultSettings) {\n  return new IndexSet(cfg, defaultSettings);\n}\nvar IndexUtils = {\n  sanitizeConfig: function sanitizeConfig(cfg, localDefaults) {\n    // if (isString(cfg)) {\n    //   // only provide a single index that is the name of the index and the name of the property it's indexing\n    //   const cfgEntry = {\n    //     keys: [cfg]\n    //   };\n    //   return {\n    //     [cfg]: Object.assign({}, globalDefaultConfig, localDefaults, cfgEntry)\n    //   };\n    // }\n    // else \n    if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default()(cfg)) {\n      return lodash_zipObject__WEBPACK_IMPORTED_MODULE_11___default()(lodash_keys__WEBPACK_IMPORTED_MODULE_15___default()(cfg), lodash_map__WEBPACK_IMPORTED_MODULE_12___default()(cfg, function (indexCfg) {\n        var cfgEntry;\n\n        if (lodash_isArray__WEBPACK_IMPORTED_MODULE_0___default()(indexCfg)) {\n          // only provide array of keys\n          cfgEntry = {\n            keys: indexCfg\n          };\n        } else if (lodash_isString__WEBPACK_IMPORTED_MODULE_2___default()(indexCfg)) {\n          // only provide name of single key\n          cfgEntry = {\n            keys: [indexCfg]\n          };\n        } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default()(indexCfg)) {\n          // provide full configuration for index\n          if (!lodash_isArray__WEBPACK_IMPORTED_MODULE_0___default()(indexCfg.keys)) {//console.warn('Invalid index config missing or invalid keys property (should be array): ' + JSON.stringify(cfg));\n          }\n\n          cfgEntry = indexCfg;\n        } else {\n          //console.warn('Invalid index config has invalid entry: ' + indexName);\n          cfgEntry = {};\n        }\n\n        return Object.assign({}, globalDefaultConfig, localDefaults, cfgEntry);\n      }));\n    } else {\n      throw new Error('invalid `indices` config, must be plain object or string: ' + JSON.stringify(cfg));\n    }\n  },\n  convertToSortedValueSet: function convertToSortedValueSet(val, nDepth) {\n    var _this = this;\n\n    nDepth = nDepth || 0;\n\n    if (nDepth > 10) {\n      console.error('[ERROR] Could not encode value; possible recursive values: ' + val);\n      return null;\n    }\n\n    if (val === undefined) {\n      val = null;\n    }\n\n    if (lodash_isString__WEBPACK_IMPORTED_MODULE_2___default()(val)) {\n      return val;\n    } else if (lodash_isArrayLike__WEBPACK_IMPORTED_MODULE_3___default()(val)) {\n      return lodash_map__WEBPACK_IMPORTED_MODULE_12___default()(val, function (child) {\n        return _this.convertToSortedValueSet(child, nDepth + 1);\n      });\n    } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default()(val)) {\n      // make sure, entries in resulting string representation are sorted by key\n      var converted = lodash_flatten__WEBPACK_IMPORTED_MODULE_18___default()(lodash_map__WEBPACK_IMPORTED_MODULE_12___default()(val, function (v, k) {\n        return [k, _this.convertToSortedValueSet(v)];\n      }));\n      return lodash_sortBy__WEBPACK_IMPORTED_MODULE_10___default()(converted, function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            k = _ref2[0],\n            v = _ref2[1];\n\n        return k;\n      });\n    }\n\n    return val;\n  },\n  encodeValue: function encodeValue(val, forceSimple) {\n    if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_4___default()(val) || lodash_isElement__WEBPACK_IMPORTED_MODULE_5___default()(val) || lodash_isError__WEBPACK_IMPORTED_MODULE_6___default()(val)) {\n      throw new Error('[ERROR] Cannot encode element or functions - ' + val);\n    }\n\n    if (lodash_isString__WEBPACK_IMPORTED_MODULE_2___default()(val) || lodash_isBoolean__WEBPACK_IMPORTED_MODULE_8___default()(val) || lodash_isNumber__WEBPACK_IMPORTED_MODULE_7___default()(val) || val === null) {\n      return val;\n    }\n\n    if (lodash_isDate__WEBPACK_IMPORTED_MODULE_9___default()(val)) {\n      return val.getTime();\n    }\n\n    if (forceSimple) {\n      if (lodash_isArrayLike__WEBPACK_IMPORTED_MODULE_3___default()(val)) {\n        return lodash_join__WEBPACK_IMPORTED_MODULE_19___default()(val, \"\\uFFFF\");\n      } else if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default()(val)) {\n        // object should already have been converted to a sorted array\n        throw new Error('[ERROR] Something went wrong... object could not be encoded: ' + JSON.stringify(val));\n      } // else if (isMap(val) || isSet(val) || isBuffer(val)) {\n      //   throw new Error('[ERROR] NYI - cannot yet encode values of this type: ' + val);\n      // }\n      else {\n          throw new Error('[ERROR] Could not encode value (unknown type): ' + val);\n        }\n    } else {\n      return lodash_isArrayLike__WEBPACK_IMPORTED_MODULE_3___default()(val) && JSON.stringify(val) || val;\n    }\n  },\n  // makes sure that two vals will always convert to the same string\n  // given that the structure of any two different vals of the same set does not change too much.\n  encodeValueDeep: function encodeValueDeep(val, forceSimple) {\n    return this.encodeValue(this.convertToSortedValueSet(val), forceSimple);\n  }\n};\n/**\n * Represents a set of indices that can be attached to path nodes to support\n * queries by value of child nodes.\n */\n\nvar IndexSet =\n/*#__PURE__*/\nfunction () {\n  /**\n   * {cfg} Index definitions: Each index name is assigned an array of all keys that participate in it.\n   */\n  function IndexSet(cfg, defaultSettings) {\n    _classCallCheck(this, IndexSet);\n\n    // the cfg object supports some short-hands, which are unrolled in completeCfg\n    var completeCfg = IndexUtils.sanitizeConfig(cfg, defaultSettings); // create object of type { indexName => [ key1, key2...] }\n\n    var keysByIndexName = lodash_mapValues__WEBPACK_IMPORTED_MODULE_13___default()(completeCfg, 'keys');\n    keysByIndexName = lodash_mapValues__WEBPACK_IMPORTED_MODULE_13___default()(keysByIndexName, function (keySet) {\n      return lodash_sortBy__WEBPACK_IMPORTED_MODULE_10___default()(keySet);\n    }); // create object of type { key => [indexName1, indexName2...] }\n\n    var indexNamesByKey = {};\n\n    var _loop = function _loop(indexName) {\n      var keys = keysByIndexName[indexName];\n      keys.forEach(function (key) {\n        //console.assert(isArrayLike(indexNamesByKey[key]), 'invalid index with key `' + key + '` (is not but) must be array ' + indexNamesByKey[key]);\n        var arr = indexNamesByKey[key];\n\n        if (!arr) {\n          arr = indexNamesByKey[key] = [];\n        }\n\n        arr.push(indexName);\n      });\n    };\n\n    for (var indexName in keysByIndexName) {\n      _loop(indexName);\n    }\n\n    this.cfg = completeCfg;\n    this.indexNames = lodash_keys__WEBPACK_IMPORTED_MODULE_15___default()(keysByIndexName);\n    this.allKeys = lodash_keys__WEBPACK_IMPORTED_MODULE_15___default()(indexNamesByKey);\n    this.keysByIndexName = keysByIndexName;\n    this.indexNamesByKey = indexNamesByKey;\n  } // names of all indices this key is participating in\n\n\n  _createClass(IndexSet, [{\n    key: \"getIndexNamesByKey\",\n    value: function getIndexNamesByKey(key) {\n      return this.indexNamesByKey[key];\n    }\n  }, {\n    key: \"getIndexNameByKeys\",\n    value: function getIndexNameByKeys(keys) {\n      //return findKey(this.keysByIndexName, v => isEqual(v, keys));\n      return lodash_findKey__WEBPACK_IMPORTED_MODULE_14___default()(this.keysByIndexName, function (keyArr) {\n        return cmpIgnoreOrder(keyArr, keys);\n      });\n    }\n  }, {\n    key: \"doesQueryMatchAnyIndex\",\n    value: function doesQueryMatchAnyIndex(query) {\n      return !!this.getIndexNameOfQuery(query);\n    }\n  }, {\n    key: \"doesQueryMatchAnyPropertyIndex\",\n    value: function doesQueryMatchAnyPropertyIndex(query) {\n      var indexName = this.getIndexNameOfQuery(query);\n      return indexName && this.cfg[indexName].isProperty;\n    } // array of keys participating in the given query\n\n  }, {\n    key: \"getKeysOfQuery\",\n    value: function getKeysOfQuery(query) {\n      return Object.keys(query);\n    } //  \n\n  }, {\n    key: \"getIndexNameOfQuery\",\n    value: function getIndexNameOfQuery(query) {\n      var name = this.getIndexNameByKeys(Object.keys(query)); //console.assert(name,);\n\n      return name;\n    } // whether the given key (or: child property) participates in any index\n\n  }, {\n    key: \"isIndexedKey\",\n    value: function isIndexedKey(key) {\n      return !!this.indexNamesByKey[key];\n    }\n  }, {\n    key: \"_invalidQuery\",\n    value: function _invalidQuery(query) {\n      throw new Error(\"Keys of query do not match any index: \".concat(JSON.stringify(query), \".\\nAll indices: \").concat(JSON.stringify(this.keysByIndexName, null, 2)));\n    }\n  }, {\n    key: \"where\",\n    value: function where(query) {\n      // console.log({\n      //   orderByChild: indexName,\n      //   equalTo: queryValue\n      // });\n      var keys = Object.keys(query);\n      var indexName = this.getIndexNameByKeys(keys);\n\n      if (!indexName) {\n        this._invalidQuery(query);\n      }\n\n      return [['orderByChild', indexName], ['equalTo', this.encodeQueryValueByKeys(query, keys)]];\n    } //encodeQueryValueForProps(query) {\n\n  }, {\n    key: \"encodeQueryValueForProps\",\n    value: function encodeQueryValueForProps(props, varName, iArg) {\n      var query;\n\n      if (!props.hasOwnProperty(varName)) {\n        // variable value was not explicitely provided, but maybe the props match the index signature\n        query = props;\n        var indexName = this.getIndexNameOfQuery(query);\n\n        if (!indexName || indexName !== varName) {\n          debugger;\n          throw new Error(\"tryEncodeQueryValueForProps failed. props do not contain index \".concat(varName, \" \") + 'and does not match index signature either: ' + Object.keys(query));\n        }\n      } else {\n        query = props[varName];\n      }\n\n      var keys = Object.keys(query);\n\n      if (!this.getIndexNameByKeys(keys)) {\n        this._invalidQuery(query);\n      }\n\n      return this.encodeQueryValueByKeys(query, keys);\n    }\n  }, {\n    key: \"encodeQueryValueByKeys\",\n    value: function encodeQueryValueByKeys(val, keys) {\n      if (!keys || !keys.length) {\n        console.error('Invalid query: keys are empty.');\n        return null;\n      }\n\n      var indexName = this.getIndexNameByKeys(keys);\n\n      if (!indexName) {\n        this._invalidQuery(keys);\n      }\n\n      keys = this.keysByIndexName[indexName];\n      var settings = this.getCfg(indexName);\n\n      if (keys.length === 1) {\n        return IndexUtils.encodeValueDeep(val[keys[0]], settings.forceSimpleEncoding);\n      }\n\n      var values = lodash_map__WEBPACK_IMPORTED_MODULE_12___default()(keys, function (key) {\n        return val[key];\n      });\n      return IndexUtils.encodeValueDeep(values, settings.forceSimpleEncoding);\n    }\n  }, {\n    key: \"getCfg\",\n    value: function getCfg(indexName) {\n      return this.cfg[indexName];\n    } // called before write to any object of indexed path\n\n  }, {\n    key: \"updateIndices\",\n    value: function updateIndices(val) {\n      if (!lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default()(val)) return;\n\n      for (var indexName in this.keysByIndexName) {\n        var cfg = this.getCfg(indexName); // isProperty must be true, and either updateOnWrite is true, or index has not been written yet\n\n        if (cfg.isProperty && (cfg.updateOnWrite || !val[indexName])) {\n          var _keys = this.keysByIndexName[indexName]; // single-entry keys are already properties don't need explicit writes\n\n          if (_keys.length < 2) continue;\n\n          if (lodash_some__WEBPACK_IMPORTED_MODULE_16___default()(_keys, function (key) {\n            return !lodash_has__WEBPACK_IMPORTED_MODULE_17___default()(val, key);\n          })) {\n            // problem: at least one of the participating keys is missing!\n            if (this.cfg[indexName].isRequired) {\n              console.warn(\"Could not update indices on object because value did not define index \\\"\".concat(indexName, \"\\\", and is also missing some of its keys: \\n              [\").concat(_keys, \"]\\n\").concat(JSON.stringify(val)));\n            }\n\n            continue;\n          }\n\n          val[indexName] = this.encodeQueryValueByKeys(val, _keys);\n        }\n      }\n    }\n  }]);\n\n  return IndexSet;\n}();\n\n//# sourceURL=webpack://dbdi/./indices.js?");

/***/ }),

/***/ "./util/auto-bind.js":
/*!***************************!*\
  !*** ./util/auto-bind.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (self) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.getOwnPropertyNames(self.constructor.prototype)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      if (key !== 'constructor' && key !== 'arguments' && key !== 'caller') {\n        var val = self[key];\n\n        if (typeof val === 'function') {\n          self[key] = val.bind(self);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return self;\n};\n\n//# sourceURL=webpack://dbdi/./util/auto-bind.js?");

/***/ }),

/***/ "./util/index.js":
/*!***********************!*\
  !*** ./util/index.js ***!
  \***********************/
/*! exports provided: asArray, interject, EmptyObject, EmptyArray, waitAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asArray\", function() { return asArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interject\", function() { return interject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyObject\", function() { return EmptyObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyArray\", function() { return EmptyArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"waitAsync\", function() { return waitAsync; });\n/* harmony import */ var lodash_flatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/flatMap */ \"../node_modules/lodash/flatMap.js\");\n/* harmony import */ var lodash_flatMap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_flatMap__WEBPACK_IMPORTED_MODULE_0__);\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n // If collection is array, return collection, \n//  else we assume it to be an object, and only return it's values array.\n\nfunction asArray(collection) {\n  return collection; // return isArray(collection) ? collection : (\n  //     isObject(collection) ? values(collection) : null\n  //   );\n}\n/**\n * Creates new array with new element interjected \n * between any two existing elements.\n * The given callback returns the interjected element\n * for the three arguments: arr[index], arr[index+1], index.\n * @see https://stackoverflow.com/questions/31879576/what-is-the-most-elegant-way-to-insert-objects-between-array-elements\n */\n\nfunction interject(arr, cb) {\n  return lodash_flatMap__WEBPACK_IMPORTED_MODULE_0___default()(arr, function (value, index, array) {\n    return array.length - 1 !== index // insert new object only if not already at the end\n    ? [value, cb(value, arr[index + 1], index)] : value;\n  });\n}\nvar EmptyObject = Object.freeze({});\nvar EmptyArray = Object.freeze([]);\nfunction waitAsync(_x) {\n  return _waitAsync.apply(this, arguments);\n}\n\nfunction _waitAsync() {\n  _waitAsync = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee(ms) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (r, j) {\n              return setTimeout(r, ms);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  return _waitAsync.apply(this, arguments);\n}\n\n//# sourceURL=webpack://dbdi/./util/index.js?");

/***/ }),

/***/ "./util/pathUtil.js":
/*!**************************!*\
  !*** ./util/pathUtil.js ***!
  \**************************/
/*! exports provided: pathJoin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathJoin\", function() { return pathJoin; });\n// see: http://stackoverflow.com/a/29855282/2228771\nfunction pathJoin() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n\n  parts = parts.filter(function (p) {\n    return !!p;\n  });\n  var separator = '/';\n  var replace = new RegExp(separator + '{1,}', 'g');\n  return parts.join(separator).replace(replace, separator);\n}\n\n//# sourceURL=webpack://dbdi/./util/pathUtil.js?");

/***/ })

}]);